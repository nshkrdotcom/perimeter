Excellent. The library documentation is shaping up nicely. The final core document needed is an **API Reference**. This is crucial for users who know what they want to do and just need to look up the specifics of a function or macro.

This document will be generated by `ex_doc` but we'll structure the modules and their `@moduledoc` and `@doc` attributes to produce a clear and comprehensive reference. I'll outline the key modules and their documentation here.

This would live in the `lib/` directory and be the source for the final HexDocs page.

---

### `lib/perimeter/contract.ex` (Final API-focused version)

```elixir
defmodule Perimeter.Contract do
  @moduledoc """
  A DSL for defining declarative data contracts.

  Contracts are the core of `Perimeter`. They provide a single source of truth
  for the expected shape, types, and constraints of your data. These contracts
  are defined at compile time and are used by `Perimeter.Guard` to validate
  data at runtime.

  ## Key Concepts

  - **Declarative:** You describe *what* valid data looks like, not *how* to validate it.
  - **Composable:** Simple contracts can be composed into more complex ones.
  - **Executable Documentation:** Contracts serve as a reliable, always-up-to-date
    reference for your data structures.

  This module's macros are typically made available via `use Perimeter`.
  """

  @doc """
  Defines a contract.

  A contract is a named set of rules that are evaluated within the `do` block.

  ### Example

      defcontract :create_user_params do
        required :email, :string, format: ~r/@/
        optional :name, :string, max_length: 100
      end
  """
  defmacro defcontract(name, do: block)

  @typedoc """
  The type of a field in a contract. Can be a basic type, a nested type, or `:any`.
  """
  @type field_type ::
          :string
          | :integer
          | :float
          | :boolean
          | :atom
          | :map
          | :list
          | :utc_datetime
          | :date
          | :time
          | {:list, field_type()}
          | {:map, keyword()}
          | :any

  @doc """
  Defines a required field within a contract.

  The function will return an error if this field is missing (`nil` is considered missing).

  ### Options

  - `in`: A list of allowed values.
  - `min_length`: Minimum length for a string.
  - `max_length`: Maximum length for a string.
  - `format`: A regular expression that the string must match.
  - `min`: The minimum allowed value for an integer or float.
  - `max`: The maximum allowed value for an integer or float.
  - `min_items`: The minimum number of items in a list.
  - `max_items`: The maximum number of items in a list.

  ### Examples

      required :status, :atom, in: [:active, :archived]
      required :name, :string, min_length: 2
      required :age, :integer, min: 18
  """
  defmacro required(field, type, opts \\ [])

  @doc """
  Defines an optional field within a contract.

  The validation will pass if the field is missing. If the field is present,
  it must conform to the given type and options.

  ### Options

  Accepts all the same options as `required/3`, plus:

  - `default`: A value to be injected into the data if the key is missing.
    The guard will pass this enriched data to your function.

  ### Examples

      optional :role, :string, default: "user"
      optional :nickname, :string
  """
  defmacro optional(field, type, opts \\ [])

  @doc """
  Registers a custom validation function to be run after all field validations.

  The function must be defined in the same module and should accept one argument
  (the map of validated data). It must return `:ok` on success or
  `{:error, %{field: atom(), error: String.t()}}` on failure.

  ### Example

      defcontract :event do
        required :start_at, :utc_datetime
        required :end_at, :utc_datetime
        validate :end_at_must_be_after_start_at
      end

      defp end_at_must_be_after_start_at(params) do
        # ... logic ...
      end
  """
  defmacro validate(function_name)

  @doc """
  Composes one or more existing contracts into the current one.

  This is a powerful tool for building reusable contracts and avoiding repetition.
  The macro accepts a single contract name or a list of names.

  ### Example

      defmodule Shared do
        use Perimeter.Contract
        defcontract :timestamps, do: # ...
      end

      defmodule User do
        use Perimeter.Contract
        import Shared

        defcontract :user_output do
          required :id, :string
          compose :timestamps  # All fields from :timestamps are included here
        end
      end
  """
  defmacro compose(contract_name_or_names)
end
```
---
### `lib/perimeter/guard.ex` (Final API-focused version)

```elixir
defmodule Perimeter.Guard do
  @moduledoc """
  Provides the `@guard` macro to enforce contracts at function boundaries.

  The guard is the mechanism that creates the "Defensive Perimeter." It wraps
  a function definition, creating a layer of protection that validates incoming
s  data before your function's code is ever executed.

  This module's macros are typically made available via `use Perimeter`.
  """

  @doc """
  Guards a function with an input and/or output contract.

  This macro must be placed directly above a function definition (`def` or `defp`).
  It analyzes the function below it and wraps it in validation logic.

  ### Options

  - `:input` (required): The atom name of the contract to validate the function's
    first argument against.
  - `:output` (optional): The atom name of the contract to validate the function's
    success return value (`{:ok, value}`). The `value` is what gets validated.
    Error tuples (`{:error, _}`) are passed through without validation.
  - `:enforcement` (optional): Overrides the global enforcement level for this specific
    guard. Can be `:strict`, `:warn`, or `:log`.

  ### How it Works

  At compile time, `@guard` transforms your function definition.
  For example, this:

      @guard input: :my_contract
      def my_function(params) do
        # ... your code ...
      end

  Is conceptually transformed into this:

      def my_function(params) do
        case Perimeter.validate(MyModule, :my_contract, params) do
          {:ok, validated_params} ->
            # Call the original function body
            __original_my_function__(validated_params)
          {:error, error} ->
            # Handle violation based on enforcement level
            Perimeter.ViolationHandler.handle(error, :strict)
        end
      end
  """
  defmacro guard(opts)
end
```

---
### `lib/perimeter/validator.ex` (A new module for the public API)

```elixir
defmodule Perimeter.Validator do
  @moduledoc """
  Provides a public API for programmatic contract validation.

  While `@guard` is the most common way to use Perimeter, you may sometimes
  need to manually trigger validation. This module provides a stable, public
  interface for doing so.
  """

  @doc """
  Validates data against a contract.

  This is the primary function for manual validation. It returns a standard
  `{:ok, transformed_data}` or `{:error, %Perimeter.Error{}}` tuple.

  ### Parameters
    - `module`: The module where the contract is defined.
    - `contract_name`: The atom name of the contract.
    - `data`: The map of data to validate.

  ### Returns
    - `{:ok, data}`: If validation is successful. The returned `data` may be
      enriched with default values defined in the contract.
    - `{:error, %Perimeter.Error{}}`: If validation fails.

  ### Example

      data = %{email: "test@example.com"}
      case Perimeter.Validator.validate(MyApp.UserContracts, :create_user, data) do
        {:ok, validated_data} ->
          # Continue processing
          Accounts.create_user(validated_data)
        {:error, error} ->
          # Handle the validation error
          Logger.error("Invalid user data: #{inspect(error)}")
      end
  """
  @spec validate(module :: module(), contract_name :: atom(), data :: map()) ::
          {:ok, map()} | {:error, Perimeter.Error.t()}
  def validate(module, contract_name, data) do
    # ... implementation delegates to internal validation logic ...
  end

  @doc """
  Validates data, raising an exception on failure.

  This is a convenience function useful in contexts where you expect data to
  be valid, such as in tests or after data has already been sanitized.

  ### Returns
    - `data`: The validated (and possibly transformed) data map if successful.

  ### Raises
    - `Perimeter.ValidationError`: If the validation fails. The exception struct
      contains the underlying `Perimeter.Error` struct.

  ### Example

      # In a test, where you expect validation to pass
      valid_data = %{email: "test@example.com"}
      validated_data = Perimeter.Validator.validate!(MyApp.UserContracts, :create_user, valid_data)
      assert validated_data.email == "test@example.com"
  """
  @spec validate!(module :: module(), contract_name :: atom(), data :: map()) :: map()
  def validate!(module, contract_name, data) do
    case validate(module, contract_name, data) do
      {:ok, validated_data} -> validated_data
      {:error, error} -> raise Perimeter.ValidationError, error: error
    end
  end
end

# Define the custom exception
defmodule Perimeter.ValidationError do
  defexception [:message, :error]

  @impl true
  def exception(opts) do
    error = Keyword.fetch!(opts, :error)
    message = "Perimeter contract validation failed. #{error.message}"
    %__MODULE__{message: message, error: error}
  end
end
```

---
This set of documented modules provides a solid foundation for the library's HexDocs. It clearly separates the concerns:

*   `Perimeter.Contract`: For users **defining** data shapes.
*   `Perimeter.Guard`: For users **enforcing** those shapes.
*   `Perimeter.Validator`: For users who need to **manually trigger** validation.
*   `Perimeter.Error`: For users who need to **handle failures**.

The documentation is rich with examples and clearly explains the "how" and "why," directly tying back to the core philosophy you established. This completes the core set of documentation needed for a successful v0.1.0 release.
