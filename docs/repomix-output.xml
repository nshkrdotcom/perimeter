This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter).

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
0001_final_analysis.md
0001.md
defensive_perimeter_implementation.md
ELIXIR_1_20_0_DEV_ANTIPATTERNS.md
error_handling_type_safety.md
jido_architectural_analysis.md
migration_strategy_guide.md
PERIMETER_CACHING_STRATEGIES.md
PERIMETER_gem_0001.md
PERIMETER_gem_0002.md
PERIMETER_gem_0003.md
PERIMETER_gem_0004.md
PERIMETER_gem_0005.md
PERIMETER_gem_0006.md
PERIMETER_gem_0010.md
PERIMETER_gem_0011.md
PERIMETER_gem_0012.md
PERIMETER_LIBRARY_IMPLEMENTATION_GUIDE.md
PERIMETER_LIBRARY_IMPLEMENTATION_PROMPTS.md
type_contract_best_practices.md
type_enforcement_library_spec.md
type_perimeters_design.md
type_relationships_formal_spec.md
type_safe_metaprogramming_patterns.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="0001_final_analysis.md">
# Final Analysis of Jido Dialyzer Issues

## Root Cause

The dialyzer errors stem from a fundamental design issue in the Jido framework:

1. **Two Different Struct Definitions**: 
   - `Jido.Agent` module defines a struct with all fields (name, description, etc.)
   - Generated modules (like `JidoBugDemo.TestAgent`) were creating a different struct with only a subset of fields

2. **Type Mismatch in Callbacks**:
   - Behavior callbacks are defined to accept `Jido.Agent.t()` 
   - But generated modules pass their own struct type `JidoBugDemo.TestAgent.t()`
   - Dialyzer correctly identifies this as a type contract violation

3. **Recursive Call Issues**:
   - Functions like `set/3` make recursive calls passing `opts` as `any()` type
   - But the spec requires `keyword()` type

## Solutions Applied

### 1. Relaxed Type Specifications (Partial Fix)
Changed function specs to accept `any()` instead of `keyword()` for opts parameters:
- `set/3`, `validate/2`, `cmd/4`, `run/2`

This fixed the recursive call issues but not the struct type mismatches.

### 2. Fixed on_before_plan Callback
Changed from passing `nil` to passing the actual instruction list.

### 3. Struct Alignment (Attempted)
Tried to make generated modules create structs matching Jido.Agent structure, but this created new callback mismatches.

## The Fundamental Issue

The framework has a structural design problem:
- Behaviors in Elixir can't properly express "the implementing module's type" in callbacks
- The framework tries to generate modules that look like they have the same struct as Jido.Agent
- But dialyzer sees them as different types

## Recommended Solutions

### Option 1: Single Struct Type (Most Compatible)
Make all agents use the exact same struct type by having generated modules directly use %Jido.Agent{} structs instead of their own.

### Option 2: Generic Callbacks (Less Type-Safe)
Change all callbacks to accept `any()` or `map()` instead of specific struct types.

### Option 3: Parameterized Module (Complex)
Redesign the framework to use a different pattern that doesn't rely on behaviors with struct types.

## Current Status

- Fixed the opts type issues (reduced from 10 to 9 errors)
- Identified the core struct type mismatch issue
- Further fixes require architectural changes to the framework
</file>

<file path="0001.md">
# Jido Framework Dialyzer Type Contract Investigation

## Issue Summary

When running dialyzer on pipeline_ex with MABEAM agents that use the Jido framework, we encounter multiple contract violation errors that appear to originate from within the Jido framework itself. However, when running dialyzer directly on the Jido framework, it passes successfully with only 5 skipped warnings.

## Evidence of the Problem

### 1. Jido Framework Dialyzer Results (Clean)
```bash
home@Desktop:~/p/g/n/agentjido/jido$ mix dialyzer
# ... compilation output ...
Total errors: 5, Skipped: 5, Unnecessary Skips: 0
done in 0m2.64s
done (passed successfully)
```

### 2. Pipeline_ex with MABEAM Agents (52 Errors)
```bash
home@Desktop:~/p/g/n/pipeline_ex$ mix dialyzer --no-check
# ... shows 52 total errors, many from deps/jido/lib/jido/agent.ex ...
```

## Root Cause Analysis

### The Contract Violation Pattern

The specific errors follow this pattern:

```
deps/jido/lib/jido/agent.ex:592:call
The function call will not succeed.

Pipeline.MABEAM.Agents.PipelineManager.set(_ :: %Pipeline.MABEAM.Agents.PipelineManager{}, _ :: map(), _ :: any())

breaks the contract
(t() | Jido.server(), :elixir.keyword() | map(), :elixir.keyword()) :: agent_result()
```

### The Source Code Analysis

**File:** `deps/jido/lib/jido/agent.ex`

**Line 587:** Type specification
```elixir
@spec set(t() | Jido.server(), keyword() | map(), keyword()) :: agent_result()
```

**Line 588:** Function definition  
```elixir
def set(agent, attrs, opts \\ [])
```

**Line 590:** First function clause
```elixir
def set(%__MODULE__{} = agent, attrs, opts) when is_list(attrs) do
```

**Line 592:** Recursive call (THE PROBLEM)
```elixir
set(agent, mapped_attrs, opts)  # opts is any(), but spec requires keyword()
```

### The Issue Explanation

1. **The `@spec` on line 587** declares that the third parameter must be `keyword()`
2. **The function clause on line 590** accepts `opts` as `any()` (no type guard)
3. **The recursive call on line 592** passes `opts` (typed as `any()`) to a function expecting `keyword()`

This creates a **legitimate type contract violation** within the Jido framework itself.

## Why This Only Shows Up in Pipeline_ex

### Framework vs. Consumer Perspective

1. **When dialyzer runs on Jido alone**: It analyzes the framework in isolation where the type contracts are internally consistent within the framework's own usage patterns.

2. **When dialyzer runs on pipeline_ex**: It analyzes our MABEAM agents (which `use Jido.Agent`) in conjunction with the framework code. The `use Jido.Agent` macro generates concrete agent modules with specific type signatures that expose the contract violation.

### The Generated Code Problem

When we use `use Jido.Agent` in our modules:

```elixir
defmodule Pipeline.MABEAM.Agents.PipelineManager do
  use Jido.Agent, ...
```

The macro generates a `set/3` function for our specific agent type. Dialyzer then tries to verify that:

1. Our generated `Pipeline.MABEAM.Agents.PipelineManager.set/3` function 
2. Can be called by the framework's internal `Jido.Agent.set/3` function
3. With the framework's actual parameter types

This is where the contract violation is exposed.

## The Framework Design Flaw

This represents a **framework design issue** where:

1. The framework generates type specifications for consumer modules
2. But uses looser internal calling patterns  
3. Creating an incompatibility between generated specs and framework usage

## Potential Solutions

### Option 1: Fix the Framework Type Specification
```elixir
# Change line 587 from:
@spec set(t() | Jido.server(), keyword() | map(), keyword()) :: agent_result()

# To:
@spec set(t() | Jido.server(), keyword() | map(), keyword() | any()) :: agent_result()
```

### Option 2: Add Type Guards to Function Clauses
```elixir
# Change line 590 from:
def set(%__MODULE__{} = agent, attrs, opts) when is_list(attrs) do

# To:
def set(%__MODULE__{} = agent, attrs, opts) when is_list(attrs) and is_list(opts) do
```

### Option 3: Fix the Recursive Call Pattern
```elixir
# Ensure opts is properly typed before the recursive call
def set(%__MODULE__{} = agent, attrs, opts) when is_list(attrs) do
  mapped_attrs = Map.new(attrs)
  opts = if is_list(opts), do: opts, else: []
  set(agent, mapped_attrs, opts)
end
```

## Impact Assessment

### Functional Impact
- **Runtime behavior**: Likely no impact, as the code appears to work correctly in practice
- **Type safety**: Reduced, as the type system cannot guarantee contract compliance

### Developer Impact  
- **Dialyzer analysis**: Cannot get clean dialyzer results when using Jido agents
- **Type documentation**: Misleading type specifications for framework consumers
- **Framework confidence**: Undermines trust in the framework's type safety

## Recommendation

This is a legitimate bug in the Jido framework that should be addressed via PR. The framework is generating type specifications that are incompatible with its own internal usage patterns, which violates the fundamental contract between the framework and dialyzer's static analysis.

The fix should be implemented at the framework level rather than worked around in consumer code, as this affects all users of the Jido.Agent behavior.

## Files Requiring Investigation in Jido Framework

1. `lib/jido/agent.ex` - Lines 587-595 (the set function contract violation)
2. Any macro code that generates agent type specifications
3. Other potential similar patterns in callback specifications

## Reproduction Case Created

I have successfully created a minimal reproduction case demonstrating this issue:

### Reproduction Projects:
- `0001_v1_2_0/` - Mix project using the Hex release of Jido v1.2.0 that reproduces the dialyzer errors
- `0001_nshkrdotcom_fix_agent-server-terminate-race-condition-v2/` - Mix project using my fork from the `fix/agent-server-terminate-race-condition-v2` branch

### Test Results Confirmed:
1. **9 dialyzer errors** when running `mix dialyzer` on the reproduction project
2. **Primary error at line 592** matches exactly what was described in the analysis
3. **The issue exists in the core framework**, affecting any consumer using `use Jido.Agent`
4. **All errors stem from type specification mismatches** between generated agent code and framework expectations

This confirms the framework design issue where generated type specifications are incompatible with internal framework usage patterns.

## Next Steps

1. ✅ **COMPLETED**: Create minimal reproduction case demonstrating the issue
2. Submit PR to Jido framework with proper type specification fixes  
3. Test that the fixes don't break existing functionality
4. Verify that dialyzer passes cleanly for framework consumers

## Recommended Framework Fix

The core issue is in `lib/jido/agent.ex` line 592. The fix should be:

```elixir
# Current problematic code:
def set(%__MODULE__{} = agent, attrs, opts) when is_list(attrs) do
  mapped_attrs = Map.new(attrs)
  set(agent, mapped_attrs, opts)  # opts is any(), but spec requires keyword()
end

# Fix Option 1: Add type guard
def set(%__MODULE__{} = agent, attrs, opts) when is_list(attrs) and is_list(opts) do
  mapped_attrs = Map.new(attrs)
  set(agent, mapped_attrs, opts)
end

# Fix Option 2: Ensure opts is keyword before recursive call
def set(%__MODULE__{} = agent, attrs, opts) when is_list(attrs) do
  mapped_attrs = Map.new(attrs)
  opts = if is_list(opts), do: opts, else: []
  set(agent, mapped_attrs, opts)
end

# Fix Option 3: Update the type specification to match actual usage
@spec set(t() | Jido.server(), keyword() | map(), keyword() | any()) :: agent_result()
```
</file>

<file path="defensive_perimeter_implementation.md">
# Defensive Perimeter Implementation Guide

## Introduction

This guide provides practical implementation patterns for the "Defensive Perimeter / Offensive Interior" approach in Elixir applications. It shows how to build robust type perimeters while avoiding common antipatterns and maintaining Elixir's idiomatic style.

## Core Implementation Components

### 1. Perimeter Guard Module

The foundation of defensive perimeters is a robust guard system that validates data at entry points:

```elixir
defmodule Jido.PerimeterGuard do
  @moduledoc """
  Provides compile-time and runtime perimeter enforcement for type contracts.
  Implements the three-zone model: Defensive Perimeter, Transition Layer, and Offensive Interior.
  """
  
  defmacro __using__(opts) do
    enforcement_level = Keyword.get(opts, :enforcement, :strict)
    
    quote do
      import Jido.PerimeterGuard
      Module.register_attribute(__MODULE__, :perimeter_contracts, accumulate: true)
      Module.register_attribute(__MODULE__, :enforcement_level, persist: true)
      @enforcement_level unquote(enforcement_level)
      @before_compile Jido.PerimeterGuard
    end
  end
  
  defmacro __before_compile__(env) do
    contracts = Module.get_attribute(env.module, :perimeter_contracts)
    
    # Generate runtime validation functions
    validations = Enum.map(contracts, fn {function, contract} ->
      generate_validation(function, contract)
    end)
    
    quote do
      unquote_splicing(validations)
    end
  end
  
  defmacro guard(opts) do
    quote do
      @perimeter_contracts {unquote(opts[:function]), unquote(opts)}
    end
  end
  
  defp generate_validation(function, opts) do
    input_contract = opts[:input]
    output_contract = opts[:output]
    
    quote do
      defoverridable [{unquote(function), 2}]
      
      def unquote(function)(params, context) do
        # Defensive Perimeter: Validate inputs
        with {:ok, validated_params} <- validate_input(unquote(input_contract), params),
             {:ok, validated_context} <- validate_context(context) do
          
          # Transition Layer: Transform and normalize
          normalized_params = normalize_params(validated_params)
          
          # Offensive Interior: Execute with validated data
          result = super(normalized_params, validated_context)
          
          # Exit Perimeter: Validate output
          validate_and_wrap_output(unquote(output_contract), result)
        else
          {:error, violations} ->
            handle_perimeter_violation(violations, @enforcement_level)
        end
      end
    end
  end
end
```

### 2. Contract Validation Engine

Implement efficient contract validation that avoids defensive programming:

```elixir
defmodule Jido.ContractValidator do
  @moduledoc """
  Validates data against contracts using assertive pattern matching.
  Avoids the Non-Assertive Pattern Matching antipattern.
  """
  
  def validate(contract_module, contract_name, data) do
    contract = contract_module.__contract__(contract_name)
    
    # Build validation pipeline at compile time for efficiency
    validators = build_validators(contract)
    
    # Execute validation pipeline
    validators
    |> Enum.reduce_while({:ok, data}, fn validator, {:ok, acc} ->
      case validator.(acc) do
        {:ok, result} -> {:cont, {:ok, result}}
        {:error, _} = error -> {:halt, error}
      end
    end)
  end
  
  defp build_validators(contract) do
    contract
    |> Enum.map(&field_validator/1)
    |> add_custom_validators(contract[:validate])
  end
  
  defp field_validator({:required, field, type, opts}) do
    fn data ->
      # Assertive pattern matching - we expect the field to exist
      case Map.fetch(data, field) do
        {:ok, value} ->
          validate_field_type(field, value, type, opts)
        :error ->
          {:error, %{field: field, error: "is required"}}
      end
    end
  end
  
  defp field_validator({:optional, field, type, opts}) do
    fn data ->
      # Optional fields use dynamic access pattern
      case data[field] do
        nil -> {:ok, data}
        value -> validate_field_type(field, value, type, opts)
      end
    end
  end
  
  defp validate_field_type(field, value, type, opts) do
    # Type-specific validation with clear pattern matching
    case type do
      :string when is_binary(value) ->
        validate_string_constraints(field, value, opts)
      :integer when is_integer(value) ->
        validate_integer_constraints(field, value, opts)
      :atom when is_atom(value) ->
        validate_atom_constraints(field, value, opts)
      {:list, item_type} when is_list(value) ->
        validate_list_items(field, value, item_type, opts)
      _ ->
        {:error, %{field: field, error: "invalid type"}}
    end
  end
end
```

### 3. Transition Layer Implementation

The transition layer handles data normalization between perimeters and interior:

```elixir
defmodule Jido.TransitionLayer do
  @moduledoc """
  Handles type transformation and normalization at perimeter crossings.
  Ensures data is in the correct shape for interior processing.
  """
  
  def normalize_params(params) when is_map(params) do
    params
    |> convert_string_keys_to_atoms()
    |> normalize_nested_structures()
    |> apply_default_values()
  end
  
  # Avoid dynamic atom creation antipattern
  defp convert_string_keys_to_atoms(map) do
    Map.new(map, fn
      {key, value} when is_binary(key) ->
        # Only convert to existing atoms
        case safe_to_existing_atom(key) do
          {:ok, atom} -> {atom, value}
          :error -> {key, value}  # Keep as string if atom doesn't exist
        end
      {key, value} ->
        {key, value}
    end)
  end
  
  defp safe_to_existing_atom(string) do
    {:ok, String.to_existing_atom(string)}
  rescue
    ArgumentError -> :error
  end
  
  defp normalize_nested_structures(map) do
    Map.new(map, fn
      {key, value} when is_map(value) ->
        {key, normalize_nested_structures(value)}
      {key, value} when is_list(value) ->
        {key, Enum.map(value, &normalize_if_map/1)}
      {key, value} ->
        {key, value}
    end)
  end
  
  defp normalize_if_map(value) when is_map(value), do: normalize_nested_structures(value)
  defp normalize_if_map(value), do: value
end
```

### 4. Runtime Enforcement Configuration

Implement flexible enforcement levels for different environments:

```elixir
defmodule Jido.Runtime.Enforcement do
  @moduledoc """
  Configures and manages runtime type enforcement levels.
  Allows different strictness in development vs production.
  """
  
  use GenServer
  
  @enforcement_levels [:none, :log, :warn, :strict]
  
  def start_link(opts) do
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end
  
  def init(opts) do
    default_level = Keyword.get(opts, :default_level, :warn)
    module_overrides = Keyword.get(opts, :module_overrides, %{})
    
    state = %{
      default_level: default_level,
      module_levels: module_overrides,
      violations: :queue.new(),
      telemetry_enabled: Keyword.get(opts, :telemetry, true)
    }
    
    {:ok, state}
  end
  
  def set_level(level) when level in @enforcement_levels do
    GenServer.call(__MODULE__, {:set_default_level, level})
  end
  
  def set_module_level(module, level) when level in @enforcement_levels do
    GenServer.call(__MODULE__, {:set_module_level, module, level})
  end
  
  def handle_violation(violation, module) do
    GenServer.call(__MODULE__, {:handle_violation, violation, module})
  end
  
  def handle_call({:handle_violation, violation, module}, _from, state) do
    level = get_enforcement_level(module, state)
    
    # Emit telemetry event if enabled
    if state.telemetry_enabled do
      :telemetry.execute(
        [:jido, :perimeter, :violation],
        %{count: 1},
        %{module: module, level: level}
      )
    end
    
    response = case level do
      :none -> 
        :ok
      :log -> 
        log_violation(violation)
        :ok
      :warn ->
        warn_violation(violation)
        :ok
      :strict ->
        {:error, format_violation_error(violation)}
    end
    
    # Store violation for reporting
    new_state = %{state | violations: :queue.in({module, violation}, state.violations)}
    
    {:reply, response, new_state}
  end
  
  defp get_enforcement_level(module, state) do
    Map.get(state.module_levels, module, state.default_level)
  end
end
```

### 5. Practical Action Implementation

Here's how to implement an action with proper perimeter enforcement:

```elixir
defmodule MyApp.Actions.CreateUser do
  use Jido.Action
  use Jido.PerimeterGuard, enforcement: :strict
  use Jido.TypeContract
  
  # Define input contract
  defcontract :input do
    required :name, :string, min_length: 1, max_length: 100
    required :email, :string, format: ~r/@/
    optional :age, :integer, min: 18, max: 150
    optional :metadata, :map do
      optional :source, :string
      optional :referrer, :string
    end
    
    validate :email_unique
  end
  
  # Define output contract
  defcontract :output do
    required :id, :string
    required :user, MyApp.User
    required :created_at, :datetime
  end
  
  @impl true
  @guard function: :run, input: :input, output: :output
  def run(params, context) do
    # Interior: We can trust params are validated
    %{name: name, email: email} = params
    age = params[:age]  # Optional field access
    
    # Business logic with full confidence in data structure
    with {:ok, user} <- create_user_record(name, email, age),
         {:ok, _} <- send_welcome_email(user),
         {:ok, _} <- emit_user_created_event(user) do
      
      # Output will be validated by perimeter guard
      {:ok, %{
        id: user.id,
        user: user,
        created_at: user.inserted_at
      }}
    end
  end
  
  # Custom validation function
  defp email_unique(params) do
    case MyApp.Repo.get_by(User, email: params.email) do
      nil -> {:ok, params}
      _user -> {:error, %{field: :email, error: "has already been taken"}}
    end
  end
  
  # Interior functions work with validated data
  defp create_user_record(name, email, age) do
    %User{}
    |> User.changeset(%{name: name, email: email, age: age})
    |> MyApp.Repo.insert()
  end
end
```

### 6. Agent with Perimeter Protection

Implement an agent with proper state perimeters:

```elixir
defmodule MyApp.Agents.DataProcessor do
  use Jido.Agent
  use Jido.PerimeterGuard
  use Jido.TypeContract
  
  # State contract ensures state integrity
  defcontract :state do
    required :status, :atom, in: [:idle, :processing, :complete, :error]
    required :items_processed, :integer, min: 0
    required :items_total, :integer, min: 0
    optional :current_item, :map
    optional :errors, {:list, :map}
    
    validate :items_processed_not_greater_than_total
  end
  
  # Instruction contract for planning
  defcontract :instruction do
    required :action, :atom
    required :params, :map
    optional :timeout, :integer, min: 0
  end
  
  def initial_state do
    %{
      status: :idle,
      items_processed: 0,
      items_total: 0,
      errors: []
    }
  end
  
  @impl true
  @guard function: :on_before_plan, input: :instruction
  def on_before_plan(agent, instruction, params) do
    # Validate instruction at perimeter
    {:ok, agent}
  end
  
  @impl true
  @guard function: :on_after_run, input: :state
  def on_after_run(agent) do
    # State validation happens automatically via guard
    maybe_transition_to_complete(agent)
  end
  
  # Custom validation
  defp items_processed_not_greater_than_total(%{items_processed: processed, items_total: total}) do
    if processed <= total do
      {:ok, true}
    else
      {:error, %{field: :items_processed, error: "cannot exceed items_total"}}
    end
  end
  
  # Interior logic with validated state
  defp maybe_transition_to_complete(agent) do
    if agent.state.items_processed == agent.state.items_total do
      {:ok, %{agent | state: %{agent.state | status: :complete}}}
    else
      {:ok, agent}
    end
  end
end
```

### 7. Error Perimeter Handling

Implement proper error handling at perimeters:

```elixir
defmodule Jido.ErrorPerimeter do
  @moduledoc """
  Handles errors at type perimeters with proper context and recovery.
  """
  
  def handle_perimeter_violation(violations, enforcement_level) do
    error = %Jido.Error{
      type: :validation_error,
      message: "Contract violation at perimeter",
      details: %{
        violations: format_violations(violations),
        enforcement_level: enforcement_level
      },
      stacktrace: get_clean_stacktrace()
    }
    
    case enforcement_level do
      :strict -> {:error, error}
      :warn -> 
        Logger.warning("Perimeter violation: #{inspect(error)}")
        :ok
      :log ->
        Logger.debug("Perimeter violation: #{inspect(error)}")
        :ok
      :none ->
        :ok
    end
  end
  
  def format_violations(violations) when is_list(violations) do
    Enum.map(violations, &format_single_violation/1)
  end
  
  defp format_single_violation(%{field: field, error: error, path: path}) do
    field_path = Enum.join(path ++ [field], ".")
    "#{field_path} #{error}"
  end
  
  defp get_clean_stacktrace do
    self()
    |> Process.info(:current_stacktrace)
    |> elem(1)
    |> Enum.drop(3)  # Remove internal frames
    |> Enum.take(10)  # Limit depth
  end
end
```

## Integration Patterns

### With Phoenix Controllers

```elixir
defmodule MyAppWeb.UserController do
  use MyAppWeb, :controller
  use Jido.PerimeterGuard
  
  defcontract :create_params do
    required :user, :map do
      required :name, :string
      required :email, :string
    end
  end
  
  @guard function: :create, input: :create_params
  def create(conn, params) do
    # Params are validated at perimeter
    case MyApp.Actions.CreateUser.run(params.user, build_context(conn)) do
      {:ok, result} ->
        conn
        |> put_status(:created)
        |> render("show.json", user: result.user)
      {:error, error} ->
        conn
        |> put_status(:unprocessable_entity)
        |> render("error.json", error: error)
    end
  end
end
```

### With GenServer

```elixir
defmodule MyApp.ProcessingServer do
  use GenServer
  use Jido.PerimeterGuard
  
  defcontract :process_request do
    required :type, :atom, in: [:sync, :async]
    required :data, :map
    optional :callback, :function
  end
  
  def process(server, request) do
    GenServer.call(server, {:process, request})
  end
  
  @guard function: :handle_call, input: :process_request
  def handle_call({:process, request}, from, state) do
    # Request validated at perimeter
    result = do_process(request.type, request.data)
    {:reply, result, state}
  end
end
```

## Performance Optimization

### 1. Compile-Time Contract Resolution

```elixir
defmodule Jido.ContractCompiler do
  @moduledoc """
  Compiles contracts into optimized validation functions at compile time.
  """
  
  defmacro compile_contract(contract) do
    # Generate optimized validation code
    validators = build_validator_ast(contract)
    
    quote do
      def __compiled_validator__ do
        fn data ->
          unquote(validators)
        end
      end
    end
  end
end
```

### 2. Validation Caching

```elixir
defmodule Jido.ValidationCache do
  @moduledoc """
  Caches validation results for frequently validated data structures.
  """
  
  use GenServer
  
  def validate_with_cache(contract, data) do
    cache_key = :erlang.phash2({contract, data})
    
    case :ets.lookup(:validation_cache, cache_key) do
      [{^cache_key, result}] -> 
        hit_telemetry()
        result
      [] ->
        miss_telemetry()
        result = perform_validation(contract, data)
        :ets.insert(:validation_cache, {cache_key, result})
        result
    end
  end
end
```

## Testing Perimeters

### Contract Testing

```elixir
defmodule MyApp.Actions.CreateUserTest do
  use ExUnit.Case
  use Jido.ContractTesting
  
  describe "perimeter contracts" do
    contract_test MyApp.Actions.CreateUser do
      valid_inputs [
        %{name: "John", email: "john@example.com"},
        %{name: "Jane", email: "jane@example.com", age: 25}
      ]
      
      invalid_inputs [
        %{name: "", email: "john@example.com"},  # Empty name
        %{name: "John", email: "invalid"},       # Invalid email
        %{name: "John"},                         # Missing email
        %{name: "John", email: "j@e.com", age: 17}  # Age too low
      ]
      
      valid_outputs [
        %{id: "123", user: %User{}, created_at: DateTime.utc_now()}
      ]
      
      invalid_outputs [
        %{id: 123, user: %User{}, created_at: DateTime.utc_now()},  # id not string
        %{user: %User{}, created_at: DateTime.utc_now()},           # missing id
        %{id: "123", user: nil, created_at: DateTime.utc_now()}     # nil user
      ]
    end
  end
end
```

## Conclusion

The Defensive Perimeter pattern provides a practical approach to type safety in Elixir that:

1. **Validates assertively** at system perimeters
2. **Trusts validated data** in the interior
3. **Fails fast** with clear error messages
4. **Preserves Elixir idioms** and patterns
5. **Enables metaprogramming** within safe perimeters

By implementing these patterns, you create systems that are both flexible and robust, avoiding common antipatterns while embracing Elixir's strengths.
</file>

<file path="ELIXIR_1_20_0_DEV_ANTIPATTERNS.md">
Building robust, complex systems in any language requires a deliberate approach to design. In Elixir, this robustness is deeply intertwined with the BEAM's "let it crash" philosophy and a pragmatic focus on data transformation.

While Elixir is a dynamically typed language, successful large-scale applications are not built by abandoning the principles of typing. Instead, Elixir encourages a powerful, practical approach to data integrity and system design that relies on explicit contracts and data structures over a mandatory static type system. This is achieved through a combination of:

*   **Pattern Matching:** Asserting the "shape" of data at every perimeter.
*   **Structs:** Defining clear, named data structures with known fields.
*   **Function Signatures:** Using multi-clause functions to handle different data patterns explicitly.
*   **Specifications (`@spec`)**: Providing a layer of gradual typing for static analysis with tools like Dialyzer.

When developers use these tools effectively, they create systems where the flow and structure of data are self-evident. This leads to code that is more predictable, easier to reason about, and resilient to unexpected inputs. Conversely, when these conventions are ignored, code can become brittle, obscure, and difficult to maintain.

The following anti-patterns highlight common pitfalls where these principles are overlooked. By understanding and avoiding them, you can write Elixir code that is not only correct but also clear, maintainable, and resilient, truly embracing the strengths of the language and the BEAM.

-----

## Code-Related Anti-Patterns

This document outlines potential anti-patterns related to your code and particular Elixir idioms and features.

-----

### Comments Overuse

**Problem**

When you overuse comments or comment self-explanatory code, it can make code **less readable**.

**Example**

```elixir
# Returns the Unix timestamp of 5 minutes from the current time
defp unix_five_min_from_now do
  # Get the current time
  now = DateTime.utc_now()

  # Convert it to a Unix timestamp
  unix_now = DateTime.to_unix(now, :second)

  # Add five minutes in seconds
  unix_now + (60 * 5)
end
```

**Refactoring**

Prefer **clear and self-explanatory function names, module names, and variable names** when possible. In the example above, the function name explains well what the function does, so you likely won't need the comment before it. The code also explains the operations well through variable names and clear function calls.

You could refactor the code above like this:

```elixir
@five_min_in_seconds 60 * 5

defp unix_five_min_from_now do
  now = DateTime.utc_now()
  unix_now = DateTime.to_unix(now, :second)
  unix_now + @five_min_in_seconds
end
```

We removed the unnecessary comments. We also added a `@five_min_in_seconds` module attribute, which serves the additional purpose of giving a name to the "magic" number `60 * 5`, making the code clearer and more expressive.

**Additional Remarks**

Elixir makes a clear distinction between **documentation** and code comments. The language has built-in first-class support for documentation through `@doc`, `@moduledoc`, and more. See the "Writing documentation" guide for more information.

-----

### Complex `else` Clauses in `with`

**Problem**

This anti-pattern refers to `with` expressions that flatten all their error clauses into a single complex `else` block. This situation is harmful to code readability and maintainability because it's difficult to know from which clause the error value came.

**Example**

An example of this anti-pattern, as shown below, is a function `open_decoded_file/1` that reads a Base64-encoded string content from a file and returns a decoded binary string. This function uses a `with` expression that needs to handle two possible errors, all of which are concentrated in a single complex `else` block.

```elixir
def open_decoded_file(path) do
  with {:ok, encoded} <- File.read(path),
       {:ok, decoded} <- Base.decode64(encoded) do
    {:ok, String.trim(decoded)}
  else
    {:error, _} -> {:error, :badfile}
    :error -> {:error, :badencoding}
  end
end
```

In the code above, it is unclear how each pattern on the left side of `<-` relates to their error at the end. The more patterns in a `with`, the less clear the code gets, and the more likely it is that unrelated failures will overlap each other.

**Refactoring**

In this situation, instead of concentrating all error handling within a single complex `else` block, it is better to **normalize the return types in specific private functions**. In this way, `with` can focus on the success case and the errors are normalized closer to where they happen, leading to better organized and maintainable code.

```elixir
def open_decoded_file(path) do
  with {:ok, encoded} <- file_read(path),
       {:ok, decoded} <- base_decode64(encoded) do
    {:ok, String.trim(decoded)}
  end
end

defp file_read(path) do
  case File.read(path) do
    {:ok, contents} -> {:ok, contents}
    {:error, _} -> {:error, :badfile}
  end
end

defp base_decode64(contents) do
  case Base.decode64(contents) do
    {:ok, decoded} -> {:ok, decoded}
    :error -> {:error, :badencoding}
  end
end
```

-----

### Complex Extractions in Clauses

**Problem**

When we use multi-clause functions, it is possible to extract values in the clauses for further usage and for pattern matching/guard checking. This extraction itself does not represent an anti-pattern, but when you have **extractions made across several clauses and several arguments of the same function, it becomes hard to know which extracted parts are used for pattern/guards and what is used only inside the function body**. This anti-pattern is related to `Unrelated multi-clause function`, but with implications of its own. It impairs code readability in a different way.

**Example**

The multi-clause function `drive/1` is extracting fields of an `%User{}` struct for usage in the clause expression (age) and for usage in the function body (name):

```elixir
def drive(%User{name: name, age: age}) when age >= 18 do
  "#{name} can drive"
end

def drive(%User{name: name, age: age}) when age < 18 do
  "#{name} cannot drive"
end
```

While the example above is small and does not constitute an anti-pattern, it is an example of mixed extraction and pattern matching. A situation where `drive/1` was more complex, having many more clauses, arguments, and extractions, would make it hard to know at a glance which variables are used for pattern/guards and which ones are not.

**Refactoring**

As shown below, a possible solution to this anti-pattern is to **extract only pattern/guard related variables in the signature** once you have many arguments or multiple clauses:

```elixir
def drive(%User{age: age} = user) when age >= 18 do
  %User{name: name} = user
  "#{name} can drive"
end

def drive(%User{age: age} = user) when age < 18 do
  %User{name: name} = user
  "#{name} cannot drive"
end
```

-----

### Dynamic Atom Creation

**Problem**

An **Atom** is an Elixir basic type whose value is its own name. Atoms are often useful to identify resources or express the state, or result, of an operation. Creating atoms dynamically is not an anti-pattern by itself. However, **atoms are not garbage collected by the Erlang Virtual Machine, so values of this type live in memory during a software's entire execution lifetime**. The Erlang VM limits the number of atoms that can exist in an application by default to `1_048_576`, which is more than enough to cover all atoms defined in a program, but attempts to serve as an early limit for applications which are "leaking atoms" through dynamic creation.

For these reasons, **creating atoms dynamically can be considered an anti-pattern when the developer has no control over how many atoms will be created during the software execution**. This unpredictable scenario can expose the software to unexpected behavior caused by excessive memory usage, or even by reaching the maximum number of atoms possible.

**Example**

Picture yourself implementing code that converts string values into atoms. These strings could have been received from an external system, either as part of a request into our application, or as part of a response to your application. This dynamic and unpredictable scenario poses a security risk, as these uncontrolled conversions can potentially trigger out-of-memory errors.

```elixir
defmodule MyRequestHandler do
  def parse(%{"status" => status, "message" => message} = _payload) do
    %{status: String.to_atom(status), message: message}
  end
end

MyRequestHandler.parse(%{"status" => "ok", "message" => "all good"})
%{status: :ok, message: "all good"}
```

When we use the `String.to_atom/1` function to dynamically create an atom, it essentially gains potential access to create arbitrary atoms in our system, causing us to lose control over adhering to the limits established by the BEAM. This issue could be exploited by someone to create enough atoms to shut down a system.

**Refactoring**

To eliminate this anti-pattern, developers must either **perform explicit conversions by mapping strings to atoms** or **replace the use of `String.to_atom/1` with `String.to_existing_atom/1`**. An explicit conversion could be done as follows:

```elixir
defmodule MyRequestHandler do
  def parse(%{"status" => status, "message" => message} = _payload) do
    %{status: convert_status(status), message: message}
  end

  defp convert_status("ok"), do: :ok
  defp convert_status("error"), do: :error
  defp convert_status("redirect"), do: :redirect
end

MyRequestHandler.parse(%{"status" => "status_not_seen_anywhere", "message" => "all good"})
** (FunctionClauseError) no function clause matching in MyRequestHandler.convert_status/1
```

By explicitly listing all supported statuses, you guarantee only a limited number of conversions may happen. Passing an invalid status will lead to a function clause error.

An alternative is to use `String.to_existing_atom/1`, which will only convert a string to an atom if the atom already exists in the system:

```elixir
defmodule MyRequestHandler do
  def parse(%{"status" => status, "message" => message} = _payload) do
    %{status: String.to_existing_atom(status), message: message}
  end
end

MyRequestHandler.parse(%{"status" => "status_not_seen_anywhere", "message" => "all good"})
** (ArgumentError) errors were found at the given arguments:

  * 1st argument: not an already existing atom
```

In such cases, passing an unknown status will raise as long as the status was not defined anywhere as an atom in the system. However, assuming `status` can be either `:ok`, `:error`, or `:redirect`, how can you guarantee those atoms exist? You must ensure those atoms exist somewhere **in the same module** where `String.to_existing_atom/1` is called. For example, if you had this code:

```elixir
defmodule MyRequestHandler do
  def parse(%{"status" => status, "message" => message} = _payload) do
    %{status: String.to_existing_atom(status), message: message}
  end

  def handle(%{status: status}) do
    case status do
      :ok -> ...
      :error -> ...
      :redirect -> ...
    end
  end
end
```

All valid statuses are defined as atoms within the same module, and that's enough. If you want to be explicit, you could also have a function that lists them:

```elixir
def valid_statuses do
  [:ok, :error, :redirect]
end
```

However, keep in mind using a module attribute or defining the atoms in the module body, outside of a function, are not sufficient, as the module body is only executed during compilation and it is not necessarily part of the compiled module loaded at runtime.

-----

### Long Parameter List

**Problem**

In a functional language like Elixir, functions tend to explicitly receive all inputs and return all relevant outputs, instead of relying on mutations or side-effects. As functions grow in complexity, the amount of arguments (parameters) they need to work with may grow, to a point where the **function's interface becomes confusing and prone to errors** during use.

**Example**

In the following example, the `loan/6` function takes too many arguments, causing its interface to be confusing and potentially leading developers to introduce errors during calls to this function.

```elixir
defmodule Library do
  # Too many parameters that can be grouped!
  def loan(user_name, email, password, user_alias, book_title, book_ed) do
    ...
  end
end
```

**Refactoring**

To address this anti-pattern, **related arguments can be grouped using key-value data structures**, such as maps, structs, or even keyword lists in the case of optional arguments. This effectively reduces the number of arguments and the key-value data structures add clarity to the caller.

For this particular example, the arguments to `loan/6` can be grouped into two different maps, thereby reducing its arity to `loan/2`:

```elixir
defmodule Library do
  def loan(%{name: name, email: email, password: password, alias: alias} = user, %{title: title, ed: ed} = book) do
    ...
  end
end
```

In some cases, the function with too many arguments may be a private function, which gives us more flexibility over how to separate the function arguments. One possible suggestion for such scenarios is to split the arguments in two maps (or tuples): one map keeps the data that may change, and the other keeps the data that won't change (read-only). This gives us a mechanical option to refactor the code.

Other times, a function may legitimately take half a dozen or more completely unrelated arguments. This may suggest the function is trying to do too much and would be better broken into multiple functions, each responsible for a smaller piece of the overall responsibility.

-----

### Namespace Trespassing

**Problem**

This anti-pattern manifests when a package author or a library defines modules outside of its "namespace". A library should use its name as a "prefix" for all of its modules. For example, a package named `:my_lib` should define all of its modules within the `MyLib` namespace, such as `MyLib.User`, `MyLib.SubModule`, `MyLib.Application`, and `MyLib` itself.

This is important because the Erlang VM can only load one instance of a module at a time. So if there are multiple libraries that define the same module, then they are incompatible with each other due to this limitation. By always using the library name as a prefix, it avoids module name clashes due to the unique prefix.

**Example**

This problem commonly manifests when writing an extension of another library. For example, imagine you are writing a package that adds authentication to `Plug` called `:plug_auth`. You must avoid defining modules within the `Plug` namespace:

```elixir
defmodule Plug.Auth do
  # ...
end
```

Even if `Plug` does not currently define a `Plug.Auth` module, it may add such a module in the future, which would ultimately conflict with `plug_auth`'s definition.

**Refactoring**

Given the package is named `:plug_auth`, it must define modules inside the `PlugAuth` namespace:

```elixir
defmodule PlugAuth do
  # ...
end
```

**Additional Remarks**

There are few known exceptions to this anti-pattern:

  * **Protocol implementations** are, by design, defined under the protocol namespace.
  * In some scenarios, the namespace owner may allow exceptions to this rule. For example, in Elixir itself, you defined **custom Mix tasks** by placing them under the `Mix.Tasks` namespace, such as `Mix.Tasks.PlugAuth`.
  * If you are the maintainer for both `plug` and `plug_auth`, then you may allow `plug_auth` to define modules with the `Plug` namespace, such as `Plug.Auth`. However, you are responsible for avoiding or managing any conflicts that may arise in the future.

-----

### Non-Assertive Map Access

**Problem**

In Elixir, it is possible to access values from **Maps**, which are key-value data structures, either statically or dynamically.

When a key is expected to exist in a map, it must be accessed using the **`map.key` notation**, making it clear to developers (and the compiler) that the key must exist. If the key does not exist, an exception is raised (and in some cases also compiler warnings). This is also known as the static notation, as the key is known at the time of writing the code.

When a key is optional, the **`map[:key]` notation** must be used instead. This way, if the informed key does not exist, `nil` is returned. This is the dynamic notation, as it also supports dynamic key access, such as `map[some_var]`.

When you use `map[:key]` to access a key that always exists in the map, you are making the code less clear for developers and for the compiler, as they now need to work with the assumption the key may not be there. This mismatch may also make it harder to track certain bugs. If the key is unexpectedly missing, you will have a `nil` value propagate through the system, instead of raising on map access.

**Table: Comparison of map access notations**

| Access notation | Key exists | Key doesn't exist | Use case                                    |
| :-------------- | :--------- | :---------------- | :------------------------------------------ |
| `map.key`       | Returns the value | Raises `KeyError` | Structs and maps with known atom keys       |
| `map[:key]`     | Returns the value | Returns `nil`     | Any Access-based data structure, optional keys |

**Example**

The function `plot/1` tries to draw a graphic to represent the position of a point in a Cartesian plane. This function receives a parameter of `Map` type with the point attributes, which can be a point of a 2D or 3D Cartesian coordinate system. This function uses dynamic access to retrieve values for the map keys:

```elixir
defmodule Graphics do
  def plot(point) do
    # Some other code...
    {point[:x], point[:y], point[:z]}
  end
end

point_2d = %{x: 2, y: 3}
%{x: 2, y: 3}
point_3d = %{x: 5, y: 6, z: 7}
%{x: 5, y: 6, z: 7}
Graphics.plot(point_2d)
{2, 3, nil}
Graphics.plot(point_3d)
{5, 6, 7}
```

Given we want to plot both 2D and 3D points, the behavior above is expected. But what happens if we forget to pass a point with either `:x` or `:y`?

```elixir
bad_point = %{y: 3, z: 4}
%{y: 3, z: 4}
Graphics.plot(bad_point)
{nil, 3, 4}
```

The behavior above is unexpected because our function should not work with points without an `:x` key. This leads to subtle bugs, as we may now pass `nil` to another function, instead of raising early on, as shown next:

```elixir
point_without_x = %{y: 10}
%{y: 10}
{x, y, _} = Graphics.plot(point_without_x)
{nil, 10, nil}
distance_from_origin = :math.sqrt(x * x + y * y)
** (ArithmeticError) bad argument in arithmetic expression
    :erlang.*(nil, nil)
```

The error above occurs later in the code because `nil` (from missing `:x`) is invalid for arithmetic operations, making it harder to identify the original issue.

**Refactoring**

To remove this anti-pattern, we must use the dynamic `map[:key]` syntax and the static `map.key` notation according to our requirements. We expect `:x` and `:y` to always exist, but not `:z`. The next code illustrates the refactoring of `plot/1`, removing this anti-pattern:

```elixir
defmodule Graphics do
  def plot(point) do
    # Some other code...
    {point.x, point.y, point[:z]}
  end
end

Graphics.plot(point_2d)
{2, 3, nil}
Graphics.plot(bad_point)
** (KeyError) key :x not found in: %{y: 3, z: 4}
  graphic.ex:4: Graphics.plot/1
```

This is beneficial because:

  * It makes your expectations clear to others reading the code.
  * It fails fast when required data is missing.
  * It allows the compiler to provide warnings when accessing non-existent fields, particularly in compile-time structures like structs.

Overall, the usage of `map.key` and `map[:key]` encode important information about your data structure, allowing developers to be clear about their intent. The `Access` module documentation also provides useful reference on this topic. You can also consider the `Map` module when working with maps of any keys, which contains functions for fetching keys (with or without default values), updating and removing keys, traversals, and more.

An alternative to refactor this anti-pattern is to use pattern matching, defining explicit clauses for 2D vs 3D points:

```elixir
defmodule Graphics do
  # 3d
  def plot(%{x: x, y: y, z: z}) do
    # Some other code...
    {x, y, z}
  end

  # 2d
  def plot(%{x: x, y: y}) do
    # Some other code...
    {x, y}
  end
end
```

Pattern-matching is especially useful when matching over multiple keys as well as on the values themselves at once. In the example above, the code will not only extract the values but also verify that the required keys exist. If we try to call `plot/1` with a map that doesn't have the required keys, we'll get a `FunctionClauseError`:

```elixir
incomplete_point = %{x: 5}
%{x: 5}
Graphics.plot(incomplete_point)
** (FunctionClauseError) no function clause matching in Graphics.plot/1

    The following arguments were given to Graphics.plot/1:

        # 1
        %{x: 5}
```

Another option is to use structs. By default, structs only support static access to its fields. In such scenarios, you may consider defining structs for both 2D and 3D points:

```elixir
defmodule Point2D do
  @enforce_keys [:x, :y]
  defstruct [x: nil, y: nil]
end
```

Generally speaking, structs are useful when sharing data structures across modules, at the cost of adding a compile-time dependency between these modules. If module A uses a struct defined in module B, A must be recompiled if the fields in the struct B change.

In summary, Elixir provides several ways to access map values, each with different behaviors:

  * **Static access** (`map.key`): Fails fast when keys are missing, ideal for structs and maps with known atom keys.
  * **Dynamic access** (`map[:key]`): Works with any `Access` data structure, suitable for optional fields, returns nil for missing keys.
  * **Pattern matching**: Provides a powerful way to both extract values and ensure required map/struct keys exist in one operation.

Choosing the right approach depends if the keys are known upfront or not. Static access and pattern matching are mostly equivalent (although pattern matching allows you to match on multiple keys at once, including matching on the struct name).

**Additional Remarks**

This anti-pattern was formerly known as `Accessing non-existent map/struct fields`.

-----

### Non-Assertive Pattern Matching

**Problem**

Overall, Elixir systems are composed of many supervised processes, so the effects of an error are localized to a single process, and don't propagate to the entire application. A supervisor detects the failing process, reports it, and possibly restarts it. This anti-pattern arises when developers write defensive or imprecise code, capable of returning incorrect values which were not planned for, instead of programming in an assertive style through pattern matching and guards.

**Example**

The function `get_value/2` tries to extract a value from a specific key of a URL query string. As it is not implemented using pattern matching, `get_value/2` always returns a value, regardless of the format of the URL query string passed as a parameter in the call. Sometimes the returned value will be valid. However, if a URL query string with an unexpected format is used in the call, `get_value/2` will extract incorrect values from it:

```elixir
defmodule Extract do
  def get_value(string, desired_key) do
    parts = String.split(string, "&")

    Enum.find_value(parts, fn pair ->
      key_value = String.split(pair, "=")
      Enum.at(key_value, 0) == desired_key && Enum.at(key_value, 1)
    end)
  end
end

# URL query string with the planned format - OK!
Extract.get_value("name=Lucas&university=UFMG&lab=ASERG", "lab")
"ASERG"
Extract.get_value("name=Lucas&university=UFMG&lab=ASERG", "university")
"UFMG"

# Unplanned URL query string format - Unplanned value extraction!
Extract.get_value("name=Lucas&university=institution=UFMG&lab=ASERG", "university")
"institution"   # <= why not "institution=UFMG"? or only "UFMG"?
```

**Refactoring**

To remove this anti-pattern, `get_value/2` can be refactored through the use of **pattern matching**. So, if an unexpected URL query string format is used, the function will crash instead of returning an invalid value. This behavior, shown below, allows clients to decide how to handle these errors and doesn't give a false impression that the code is working correctly when unexpected values are extracted:

```elixir
defmodule Extract do
  def get_value(string, desired_key) do
    parts = String.split(string, "&")

    Enum.find_value(parts, fn pair ->
      [key, value] = String.split(pair, "=") # <= pattern matching
      key == desired_key && value
    end)
  end
end

# URL query string with the planned format - OK!
Extract.get_value("name=Lucas&university=UFMG&lab=ASERG", "name")
"Lucas"

# Unplanned URL query string format - Crash explaining the problem to the client!
Extract.get_value("name=Lucas&university=institution=UFMG&lab=ASERG", "university")
** (MatchError) no match of right hand side value: ["university", "institution", "UFMG"]
  extract.ex:7: anonymous fn/2 in Extract.get_value/2 # <= left hand: [key, value] pair
Extract.get_value("name=Lucas&university&lab=ASERG", "university")
** (MatchError) no match of right hand side value: ["university"]
  extract.ex:7: anonymous fn/2 in Extract.get_value/2 # <= left hand: [key, value] pair
```

Elixir and pattern matching promote an assertive style of programming where you handle the known cases. Once an unexpected scenario arises, you can decide to address it accordingly based on practical examples, or conclude the scenario is indeed invalid and the exception is the desired choice.

`case/2` is another important construct in Elixir that helps us write assertive code, by matching on specific patterns. For example, if a function returns `{:ok, ...}` or `{:error, ...}`, prefer to explicitly match on both patterns:

```elixir
case some_function(arg) do
  {:ok, value} -> # ...
  {:error, _} -> # ...
end
```

In particular, avoid matching solely on `_`, as shown below:

```elixir
case some_function(arg) do
  {:ok, value} -> # ...
  _ -> # ...
end
```

Matching on `_` is less clear in intent and it may hide bugs if `some_function/1` adds new return values in the future.

**Additional Remarks**

This anti-pattern was formerly known as `Speculative assumptions`.

-----

### Non-Assertive Truthiness

**Problem**

Elixir provides the concept of truthiness: `nil` and `false` are considered "falsy" and all other values are "truthy". Many constructs in the language, such as `&&/2`, `||/2`, and `!/1` handle truthy and falsy values. Using those operators is not an anti-pattern. However, **using those operators when all operands are expected to be booleans, may be an anti-pattern**.

**Example**

The simplest scenario where this anti-pattern manifests is in conditionals, such as:

```elixir
if is_binary(name) && is_integer(age) do
  # ...
else
  # ...
end
```

Given both operands of `&&/2` are booleans, the code is more generic than necessary, and potentially unclear.

**Refactoring**

To remove this anti-pattern, we can replace `&&/2`, `||/2`, and `!/1` by **`and/2`, `or/2`, and `not/1` respectively**. These operators assert at least their first argument is a boolean:

```elixir
if is_binary(name) and is_integer(age) do
  # ...
else
  # ...
end
```

This technique may be particularly important when working with Erlang code. Erlang does not have the concept of truthiness. It never returns `nil`, instead its functions may return `:error` or `:undefined` in places an Elixir developer would return `nil`. Therefore, to avoid accidentally interpreting `:undefined` or `:error` as a truthy value, you may prefer to use `and/2`, `or/2`, and `not/1` exclusively when interfacing with Erlang APIs.

-----

### Structs with 32 Fields or More

**Problem**

Structs in Elixir are implemented as compile-time maps, which have a predefined amount of fields. When structs have 32 or more fields, their internal representation in the Erlang Virtual Machines changes, potentially leading to **bloating and higher memory usage**.

**Example**

Any struct with 32 or more fields will be problematic:

```elixir
defmodule MyExample do
  defstruct [
    :field1,
    :field2,
    ...,
    :field35
  ]
end
```

The Erlang VM has two internal representations for maps: a flat map and a hash map. A flat map is represented internally as two tuples: one tuple containing the keys and another tuple holding the values. Whenever you update a flat map, the tuple keys are shared, reducing the amount of memory used by the update. A hash map has a more complex structure, which is efficient for a large amount of keys, but it does not share the key space.

Maps of up to 32 keys are represented as flat maps. All others are hash maps. Structs **are** maps (with a metadata field called `__struct__`) and so any struct with fewer than 32 fields is represented as a flat map. This allows us to optimize several struct operations, as we never add or remove fields to structs, we simply update them.

Furthermore, structs of the same name "instantiated" in the same module will share the same "tuple keys" at compilation times, as long as they have fewer than 32 fields. For example, in the following code:

```elixir
defmodule Example do
  def users do
    [%User{name: "John"}, %User{name: "Meg"}, ...]
  end
end
```

All user structs will point to the same tuple keys at compile-time, also reducing the memory cost of instantiating structs with `%MyStruct{...}` notation. This optimization is also not available if the struct has 32 keys or more.

**Refactoring**

Removing this anti-pattern, in a nutshell, requires ensuring your struct has **fewer than 32 fields**. There are a few techniques you could apply:

  * If the struct has "optional" fields, for example, fields which are initialized with `nil`, you could **nest all optional fields into another field**, called `:metadata`, `:optionals`, or similar. This could lead to benefits such as being able to use pattern matching to check if a field exists or not, instead of relying on `nil` values.
  * You could **nest structs**, by storing structs within other fields. Fields that are rarely read or written to are good candidates to be moved to a nested struct.
  * You could **nest fields as tuples**. For example, if two fields are always read or updated together, they could be moved to a tuple (or another composite data structure).

The challenge is to balance the changes above with API ergonomics, in particular, when fields may be frequently read and written to.
</file>

<file path="error_handling_type_safety.md">
# Error Handling and Type Safety Guide

## Overview

This guide demonstrates how to implement robust error handling within the "Defensive Perimeter / Offensive Interior" pattern. It shows how type-safe error handling can prevent common antipatterns while providing clear, actionable error information.

## Core Principles of Type-Safe Error Handling

### 1. Errors as First-Class Types

Instead of generic error tuples, use structured error types:

```elixir
defmodule Jido.Error do
  @moduledoc """
  Structured error representation with type safety guarantees.
  """
  
  use Jido.TypeContract
  
  @type t :: %__MODULE__{
    type: error_type(),
    message: String.t(),
    details: map(),
    stacktrace: list(),
    context: map()
  }
  
  @type error_type ::
    :validation_error |
    :execution_error |
    :timeout |
    :authorization_error |
    :not_found |
    :conflict |
    :system_error
  
  defstruct [:type, :message, :details, :stacktrace, :context]
  
  # Contract for error creation
  defcontract :error_params do
    required :type, :atom, in: [
      :validation_error, :execution_error, :timeout,
      :authorization_error, :not_found, :conflict, :system_error
    ]
    required :message, :string
    optional :details, :map
    optional :context, :map
  end
  
  @guard input: :error_params
  def new(params) do
    %__MODULE__{
      type: params.type,
      message: params.message,
      details: params[:details] || %{},
      stacktrace: get_clean_stacktrace(),
      context: params[:context] || %{}
    }
  end
  
  # Specific error constructors
  def validation_error(message, violations) when is_list(violations) do
    new(%{
      type: :validation_error,
      message: message,
      details: %{violations: format_violations(violations)}
    })
  end
  
  def not_found(resource_type, identifier) do
    new(%{
      type: :not_found,
      message: "#{resource_type} not found",
      details: %{resource_type: resource_type, identifier: identifier}
    })
  end
end
```

### 2. Error Perimeters with Pattern Matching

Avoid complex `else` clauses by using specific error handling:

```elixir
defmodule ErrorPerimeterPatterns do
  use Jido.TypeContract
  
  # Instead of complex with/else
  def process_with_perimeters(params) do
    # Each perimeter returns typed errors
    with {:ok, validated} <- validate_input(params),
         {:ok, authorized} <- check_authorization(validated),
         {:ok, result} <- execute_action(authorized) do
      {:ok, format_result(result)}
    end
  end
  
  # Perimeter functions return specific error types
  defp validate_input(params) do
    case validate_contract(:input, params) do
      {:ok, valid} -> 
        {:ok, valid}
      {:error, violations} ->
        {:error, Jido.Error.validation_error("Invalid input", violations)}
    end
  end
  
  defp check_authorization(params) do
    if authorized?(params) do
      {:ok, params}
    else
      {:error, Jido.Error.authorization_error(
        "Insufficient permissions",
        %{required_role: :admin, current_role: params[:role]}
      )}
    end
  end
  
  defp execute_action(params) do
    try do
      result = do_execute(params)
      {:ok, result}
    rescue
      e in RuntimeError ->
        {:error, Jido.Error.execution_error(
          "Action execution failed",
          %{original_error: Exception.message(e)}
        )}
    end
  end
end
```

### 3. Typed Error Propagation

Ensure errors maintain their type information through the system:

```elixir
defmodule TypedErrorPropagation do
  use Jido.TypeContract
  
  # Define error result contract
  defcontract :action_result do
    one_of [
      {:ok, :map},
      {:error, Jido.Error}
    ]
  end
  
  # Actions return typed results
  defmodule CreateUserAction do
    use Jido.Action
    
    @impl true
    @guard output: :action_result
    def run(params, context) do
      with {:ok, user} <- create_user(params),
           {:ok, _} <- send_welcome_email(user) do
        {:ok, %{user: user}}
      else
        {:error, %Jido.Error{} = error} ->
          # Propagate typed error
          {:error, enrich_error(error, params)}
        {:error, other} ->
          # Convert untyped errors
          {:error, Jido.Error.system_error(
            "Unexpected error",
            %{original: other}
          )}
      end
    end
    
    defp enrich_error(error, params) do
      %{error | 
        context: Map.merge(error.context, %{
          action: __MODULE__,
          params: sanitize_params(params)
        })
      }
    end
  end
end
```

## Error Handling Patterns

### Pattern 1: Validation Error Aggregation

Collect all validation errors instead of failing on first:

```elixir
defmodule ValidationAggregation do
  use Jido.TypeContract
  
  def validate_comprehensive(data) do
    validators = [
      &validate_required_fields/1,
      &validate_field_types/1,
      &validate_business_rules/1,
      &validate_relationships/1
    ]
    
    # Run all validators, collecting errors
    results = Enum.map(validators, fn validator ->
      case validator.(data) do
        :ok -> {:ok, []}
        {:error, violations} -> {:error, violations}
      end
    end)
    
    # Aggregate results
    case aggregate_validation_results(results) do
      [] -> 
        {:ok, data}
      violations ->
        {:error, Jido.Error.validation_error(
          "Validation failed",
          violations
        )}
    end
  end
  
  defp aggregate_validation_results(results) do
    results
    |> Enum.flat_map(fn
      {:ok, _} -> []
      {:error, violations} -> violations
    end)
    |> Enum.uniq_by(& &1.field)  # Deduplicate by field
  end
  
  defp validate_required_fields(data) do
    required = [:name, :email, :age]
    missing = required -- Map.keys(data)
    
    case missing do
      [] -> :ok
      fields ->
        violations = Enum.map(fields, fn field ->
          %{field: field, error: "is required"}
        end)
        {:error, violations}
    end
  end
end
```

### Pattern 2: Error Recovery and Compensation

Implement recovery strategies at perimeters:

```elixir
defmodule ErrorRecovery do
  use Jido.TypeContract
  
  defmodule RecoverableAction do
    use Jido.Action
    
    defcontract :recovery_strategy do
      required :type, :atom, in: [:retry, :compensate, :fallback, :fail]
      optional :max_retries, :integer, default: 3
      optional :backoff_ms, :integer, default: 1000
      optional :fallback_value, :any
    end
    
    @impl true
    def run(params, context) do
      strategy = context[:recovery_strategy] || %{type: :fail}
      
      execute_with_recovery(params, context, strategy)
    end
    
    defp execute_with_recovery(params, context, %{type: :retry} = strategy) do
      max_retries = strategy[:max_retries] || 3
      backoff = strategy[:backoff_ms] || 1000
      
      retry_with_backoff(
        fn -> do_execute(params, context) end,
        max_retries,
        backoff
      )
    end
    
    defp execute_with_recovery(params, context, %{type: :compensate}) do
      case do_execute(params, context) do
        {:ok, result} ->
          {:ok, result}
        {:error, error} ->
          case compensate(params, context, error) do
            {:ok, compensated} ->
              {:ok, compensated}
            {:error, comp_error} ->
              {:error, Jido.Error.execution_error(
                "Failed to execute and compensate",
                %{
                  original_error: error,
                  compensation_error: comp_error
                }
              )}
          end
      end
    end
    
    defp retry_with_backoff(fun, retries, backoff, attempt \\ 1) do
      case fun.() do
        {:ok, _} = result ->
          result
        {:error, error} when attempt < retries ->
          Process.sleep(backoff * attempt)
          retry_with_backoff(fun, retries, backoff, attempt + 1)
        {:error, error} ->
          {:error, enrich_with_retry_info(error, attempt)}
      end
    end
  end
end
```

### Pattern 3: Error Context Enrichment

Add context to errors as they propagate through perimeters:

```elixir
defmodule ErrorContextEnrichment do
  use Jido.TypeContract
  
  defmodule ContextualError do
    @moduledoc """
    Enriches errors with contextual information at each perimeter.
    """
    
    def with_context(error_or_result, context) do
      case error_or_result do
        {:error, %Jido.Error{} = error} ->
          {:error, add_context(error, context)}
        {:error, other} ->
          {:error, wrap_with_context(other, context)}
        result ->
          result
      end
    end
    
    defp add_context(%Jido.Error{} = error, context) do
      %{error |
        context: Map.merge(error.context, context),
        stacktrace: maybe_add_perimeter_frame(error.stacktrace)
      }
    end
    
    defp wrap_with_context(error, context) do
      Jido.Error.new(%{
        type: :system_error,
        message: "Wrapped error at perimeter",
        details: %{original_error: error},
        context: context
      })
    end
    
    def with_telemetry(error_or_result, event_name) do
      case error_or_result do
        {:error, error} ->
          :telemetry.execute(
            [:jido, :error, event_name],
            %{count: 1},
            %{error: error}
          )
          {:error, error}
        result ->
          result
      end
    end
  end
  
  # Usage in perimeters
  def process_order(order_params) do
    order_params
    |> validate_order()
    |> ContextualError.with_context(%{perimeter: :order_validation})
    |> calculate_pricing()
    |> ContextualError.with_context(%{perimeter: :pricing})
    |> check_inventory()
    |> ContextualError.with_context(%{perimeter: :inventory})
    |> ContextualError.with_telemetry(:order_processing)
  end
end
```

### Pattern 4: Type-Safe Error Transformation

Transform errors between different perimeter types:

```elixir
defmodule ErrorTransformation do
  @moduledoc """
  Transforms internal errors to appropriate external representations.
  """
  
  # Transform internal errors to HTTP responses
  def to_http_response({:error, %Jido.Error{} = error}) do
    %{
      status: error_to_status(error.type),
      body: %{
        error: %{
          type: error.type,
          message: error.message,
          details: sanitize_details(error.details)
        }
      }
    }
  end
  
  def to_http_response({:ok, result}) do
    %{status: 200, body: result}
  end
  
  defp error_to_status(type) do
    case type do
      :validation_error -> 422
      :authorization_error -> 403
      :not_found -> 404
      :conflict -> 409
      :timeout -> 408
      _ -> 500
    end
  end
  
  # Transform to GraphQL errors
  def to_graphql_error({:error, %Jido.Error{} = error}) do
    %{
      message: error.message,
      extensions: %{
        code: error.type |> Atom.to_string() |> String.upcase(),
        details: error.details
      },
      path: error.context[:graphql_path]
    }
  end
  
  # Transform to user-friendly messages
  def to_user_message({:error, %Jido.Error{} = error}) do
    case error.type do
      :validation_error ->
        format_validation_message(error.details.violations)
      :authorization_error ->
        "You don't have permission to perform this action."
      :not_found ->
        "The requested #{error.details.resource_type} could not be found."
      _ ->
        "An error occurred. Please try again later."
    end
  end
end
```

## Advanced Error Handling Patterns

### Circuit Breaker Pattern

Prevent cascading failures with typed circuit breakers:

```elixir
defmodule CircuitBreaker do
  use GenServer
  use Jido.TypeContract
  
  defcontract :breaker_config do
    required :failure_threshold, :integer, min: 1
    required :timeout_ms, :integer, min: 100
    required :reset_timeout_ms, :integer, min: 1000
  end
  
  defcontract :breaker_state do
    required :status, :atom, in: [:closed, :open, :half_open]
    required :failure_count, :integer, min: 0
    required :last_failure, :datetime, nullable: true
    required :config, :breaker_config
  end
  
  def call(breaker, fun) do
    GenServer.call(breaker, {:call, fun})
  end
  
  def handle_call({:call, fun}, _from, state) do
    case state.status do
      :open ->
        if should_attempt_reset?(state) do
          attempt_call(fun, %{state | status: :half_open})
        else
          error = Jido.Error.new(%{
            type: :circuit_open,
            message: "Circuit breaker is open",
            details: %{
              failure_count: state.failure_count,
              last_failure: state.last_failure
            }
          })
          {:reply, {:error, error}, state}
        end
        
      status when status in [:closed, :half_open] ->
        attempt_call(fun, state)
    end
  end
  
  defp attempt_call(fun, state) do
    try do
      case fun.() do
        {:ok, _} = result ->
          new_state = reset_breaker(state)
          {:reply, result, new_state}
        {:error, error} ->
          new_state = record_failure(state, error)
          {:reply, {:error, error}, new_state}
      end
    catch
      kind, reason ->
        error = Jido.Error.execution_error(
          "Circuit breaker caught exception",
          %{kind: kind, reason: reason}
        )
        new_state = record_failure(state, error)
        {:reply, {:error, error}, new_state}
    end
  end
end
```

### Error Aggregation Pipeline

Aggregate errors from multiple operations:

```elixir
defmodule ErrorAggregationPipeline do
  use Jido.TypeContract
  
  defcontract :pipeline_result do
    one_of [
      {:ok, :map},
      {:error, {:list, Jido.Error}},
      {:partial, :map, {:list, Jido.Error}}
    ]
  end
  
  def execute_pipeline(operations, initial_data) do
    results = Enum.reduce(operations, {[], initial_data}, fn operation, {errors, data} ->
      case operation.(data) do
        {:ok, new_data} ->
          {errors, Map.merge(data, new_data)}
        {:error, error} ->
          {[error | errors], data}
      end
    end)
    
    case results do
      {[], final_data} ->
        {:ok, final_data}
      {errors, partial_data} when map_size(partial_data) > map_size(initial_data) ->
        {:partial, partial_data, Enum.reverse(errors)}
      {errors, _} ->
        {:error, Enum.reverse(errors)}
    end
  end
  
  # Usage
  def process_user_registration(params) do
    operations = [
      &validate_user_data/1,
      &check_email_uniqueness/1,
      &create_user_record/1,
      &send_welcome_email/1,
      &create_initial_preferences/1
    ]
    
    case execute_pipeline(operations, params) do
      {:ok, result} ->
        {:ok, result}
      {:partial, result, errors} ->
        # Some operations succeeded
        log_partial_success(result, errors)
        {:ok, result}  # Or handle as needed
      {:error, errors} ->
        {:error, aggregate_errors(errors)}
    end
  end
end
```

## Testing Error Handling

### Contract-Based Error Testing

```elixir
defmodule ErrorContractTest do
  use ExUnit.Case
  use Jido.ContractTesting
  
  describe "error contracts" do
    test "validates error structure" do
      error = Jido.Error.validation_error("Invalid input", [
        %{field: :email, error: "is invalid"}
      ])
      
      assert %Jido.Error{
        type: :validation_error,
        message: "Invalid input",
        details: %{violations: _}
      } = error
      
      # Verify error contract
      assert_valid_contract(Jido.Error, :error_params, %{
        type: error.type,
        message: error.message,
        details: error.details
      })
    end
    
    test "error transformation preserves type safety" do
      original_error = Jido.Error.not_found("User", "123")
      
      http_response = ErrorTransformation.to_http_response({:error, original_error})
      
      assert http_response.status == 404
      assert http_response.body.error.type == :not_found
    end
  end
end
```

### Property-Based Error Testing

```elixir
defmodule ErrorPropertyTest do
  use ExUnit.Case
  use ExUnitProperties
  
  property "all error types have appropriate HTTP status codes" do
    check all error_type <- member_of([
      :validation_error, :authorization_error, :not_found,
      :conflict, :timeout, :system_error
    ]) do
      error = Jido.Error.new(%{
        type: error_type,
        message: "Test error"
      })
      
      response = ErrorTransformation.to_http_response({:error, error})
      
      assert response.status in 400..599
      assert is_map(response.body)
    end
  end
  
  property "error context enrichment preserves original error" do
    check all context <- map_of(atom(:alphanumeric), term()) do
      original_error = Jido.Error.system_error("Test", %{})
      
      enriched = ErrorContextEnrichment.ContextualError.with_context(
        {:error, original_error},
        context
      )
      
      assert {:error, %Jido.Error{} = error} = enriched
      assert error.message == original_error.message
      assert error.type == original_error.type
      
      for {key, value} <- context do
        assert error.context[key] == value
      end
    end
  end
end
```

## Error Monitoring and Observability

```elixir
defmodule ErrorObservability do
  @moduledoc """
  Provides error monitoring and alerting capabilities.
  """
  
  def setup_error_telemetry do
    :telemetry.attach_many(
      "error-monitoring",
      [
        [:jido, :error, :validation],
        [:jido, :error, :execution],
        [:jido, :error, :perimeter]
      ],
      &handle_error_event/4,
      nil
    )
  end
  
  defp handle_error_event(event, measurements, metadata, _config) do
    error = metadata.error
    
    # Log structured error data
    Logger.error("""
    Error occurred: #{error.type}
    Message: #{error.message}
    Details: #{inspect(error.details)}
    Context: #{inspect(error.context)}
    """)
    
    # Send to monitoring service
    send_to_monitoring(error, event)
    
    # Alert on critical errors
    maybe_send_alert(error)
  end
  
  defp maybe_send_alert(%Jido.Error{type: type} = error) 
    when type in [:system_error, :timeout] do
    
    Alert.send(%{
      level: :critical,
      title: "Critical error in #{error.context[:perimeter]}",
      details: error
    })
  end
  defp maybe_send_alert(_), do: :ok
end
```

## Summary

Type-safe error handling provides:

1. **Clear Error Perimeters**: Errors are caught and typed at system perimeters
2. **Structured Error Information**: Rich error types with context
3. **Avoid Antipatterns**: No defensive programming or complex error handling
4. **Better Debugging**: Clear error traces with context
5. **Graceful Degradation**: Recovery strategies and partial success handling
6. **Type Safety**: Errors maintain type information throughout the system

By implementing these patterns, you create systems that fail gracefully, provide clear error information, and maintain type safety even in error conditions.
</file>

<file path="jido_architectural_analysis.md">
# Comprehensive Architectural Analysis of Jido Framework Type System Issues

## Executive Summary

The Jido framework exhibits a fundamental architectural mismatch between its compile-time type system and runtime polymorphic behavior. This creates irreconcilable dialyzer warnings when using the framework. The core issue stems from attempting to implement object-oriented inheritance patterns in a functional language with a structural type system.

## Table of Contents
1. [Core Design Pattern](#core-design-pattern)
2. [Fundamental Design Flaws](#fundamental-design-flaws)
3. [Technical Deep Dive](#technical-deep-dive)
4. [Limitations and Tradeoffs](#limitations-and-tradeoffs)
5. [Proposed Solutions](#proposed-solutions)
6. [Recommendation](#recommendation)

## Core Design Pattern

### The Jido Agent System Architecture

The Jido framework implements an agent-based architecture with these key components:

1. **Base Module (`Jido.Agent`)**
   - Defines a behavior with callbacks
   - Creates its own struct type with fields for agent metadata and state
   - Provides a macro (`__using__/1`) for generating agent implementations

2. **Generated Agent Modules** (e.g., `JidoBugDemo.TestAgent`)
   - Created via `use Jido.Agent`
   - Generate their own struct with identical fields
   - Implement behavior callbacks
   - Are expected to be polymorphically substitutable with base type

3. **Server Process (`Jido.Agent.Server`)**
   - GenServer that hosts agent instances
   - Expects to receive `Jido.Agent.t()` types
   - Dynamically dispatches to agent module implementations

### The Type System Expectation

```elixir
# Behavior expects:
@callback on_before_run(agent :: Jido.Agent.t()) :: {:ok, Jido.Agent.t()} | {:error, term()}

# Generated module creates:
@type t :: %JidoBugDemo.TestAgent{...}

# But callback receives:
def on_before_run(%JidoBugDemo.TestAgent{} = agent) do
  # This violates the callback spec!
end
```

## Fundamental Design Flaws

### 1. **Polymorphic Struct Anti-Pattern**

The framework attempts to create polymorphic structs where different module structs are treated as interchangeable. This violates Elixir's type system principles:

```elixir
# What the framework wants (OOP-style):
abstract class Agent { ... }
class TestAgent extends Agent { ... }
Agent agent = new TestAgent(); // OK in OOP

# What actually happens in Elixir:
%Jido.Agent{} != %JidoBugDemo.TestAgent{}  # Different types!
```

### 2. **Behavior Callback Type Constraints**

Elixir behaviors cannot express "self-type" constraints:

```elixir
# Cannot express "the implementing module's struct type"
@callback do_something(agent :: t()) :: {:ok, t()}  
# 't()' here always means Jido.Agent.t(), not the implementor's type
```

### 3. **Dual Struct Definition**

The framework defines structs in two places:
- `Jido.Agent` via `typedstruct`
- Each generated module via `defstruct`

This creates type confusion where:
- Runtime uses duck typing (works fine)
- Dialyzer sees strict structural types (fails)

### 4. **Type Erasure at Module Perimeters**

When agent modules call each other or interact with the server:

```elixir
# In generated module:
def set(%__MODULE__{} = agent, attrs, opts) do
  # Calls itself recursively
  set(agent, mapped_attrs, opts)  # Dialyzer loses type precision here
end
```

## Technical Deep Dive

### The Macro Generation Process

1. **Type Aliasing Attempt**
   ```elixir
   # In macro:
   @type t :: Jido.Agent.t()  # Incorrect - creates type alias, not new type
   ```

2. **Struct Field Mismatch**
   ```elixir
   # Base module has ALL fields
   typedstruct do
     field(:id, String.t())
     field(:name, String.t())
     # ... 13 fields total
   end
   
   # Generated module initially had SUBSET
   @agent_server_schema [
     id: [...],
     dirty_state?: [...],
     # ... only 6 fields
   ]
   ```

3. **Callback Implementation Paradox**
   ```elixir
   # Behavior requires:
   @callback mount(agent :: struct(), opts :: keyword()) :: {:ok, map()}
   
   # But implementation receives:
   def mount(state, opts) do
     # state is ServerState.t(), not agent struct!
   end
   ```

### Runtime vs. Compile-time Type Handling

**Runtime (Works):**
- Uses pattern matching and duck typing
- `agent.__struct__` dynamically dispatches
- Structs are just maps with metadata

**Compile-time (Fails):**
- Dialyzer performs strict structural typing
- Each struct is a distinct type
- Cannot prove type safety across module perimeters

### The Server State Wrapping Issue

```elixir
# Some callbacks receive wrapped state:
def mount(%ServerState{agent: agent} = state, opts) do
  # agent is supposedly Jido.Agent.t()
  # but actually JidoBugDemo.TestAgent.t()
end

# Others receive bare agent:
def on_before_run(%JidoBugDemo.TestAgent{} = agent) do
  # Direct agent struct
end
```

## Limitations and Tradeoffs

### Current Architecture Limitations

1. **Type Safety**: Cannot achieve full dialyzer compliance without fundamental redesign
2. **Behavior Contracts**: Cannot express polymorphic struct relationships
3. **Macro Complexity**: Generated code creates types that don't match behavior expectations
4. **Documentation**: Type specs mislead about actual runtime behavior

### Design Tradeoffs

| Approach | Pros | Cons |
|----------|------|------|
| **Current (Polymorphic Structs)** | Intuitive OOP-like API | Dialyzer violations |
| **Single Struct Type** | Type safe | Less intuitive, no compile-time agent identity |
| **Generic Callbacks** | Flexible | Loss of type documentation |
| **Protocol-based** | True polymorphism | Major API redesign |

## Proposed Solutions

### Solution 1: Single Struct Type (Recommended)

Make all agents use `%Jido.Agent{}` struct directly:

```elixir
defmacro __using__(opts) do
  quote do
    # Don't create new struct, use Jido.Agent struct
    @behaviour Jido.Agent
    
    def new(id \\ nil, initial_state \\ %{}) do
      %Jido.Agent{
        id: id,
        name: unquote(opts[:name]),
        # ... store module in a field
        __module__: __MODULE__,
        state: initial_state
      }
    end
  end
end
```

**Pros:**
- Complete type safety
- Simple implementation
- No dialyzer warnings

**Cons:**
- Less intuitive (all agents have same struct type)
- Requires `__module__` field for dispatch

### Solution 2: Protocol-Based Architecture

Replace behaviors with protocols:

```elixir
defprotocol Jido.AgentProtocol do
  @spec validate(t, keyword) :: {:ok, t} | {:error, term}
  def validate(agent, opts)
  
  @spec run(t, keyword) :: {:ok, t, [Directive.t()]} | {:error, term}  
  def run(agent, opts)
end

# Each agent implements the protocol
defimpl Jido.AgentProtocol, for: JidoBugDemo.TestAgent do
  def validate(agent, opts), do: # ...
  def run(agent, opts), do: # ...
end
```

**Pros:**
- True polymorphism in Elixir
- Type safe
- Clear separation of concerns

**Cons:**
- Major breaking API change
- More verbose
- Protocol dispatch overhead

### Solution 3: Relaxed Type Specifications

Make all callbacks accept generic types:

```elixir
@callback on_before_run(agent :: map()) :: {:ok, map()} | {:error, term()}
@spec set(map(), keyword() | map(), any()) :: {:ok, map()} | {:error, term()}
```

**Pros:**
- Minimal code changes
- Maintains current API

**Cons:**
- Loss of type documentation
- Still not fully type safe
- Dialyzer provides less help

### Solution 4: Separate Behavior and Data

Decouple agent behavior from agent data:

```elixir
defmodule JidoBugDemo.TestAgent do
  use Jido.AgentBehavior  # Just behavior, no struct
  
  def process(agent_data, instruction) do
    # Work with generic agent_data map
  end
end

# Separate data structure
%Jido.AgentData{
  module: JidoBugDemo.TestAgent,
  state: %{},
  # ...
}
```

**Pros:**
- Clean separation
- Type safe
- Flexible

**Cons:**
- Major API redesign
- Less intuitive than current approach

## Recommendation

### Short Term (Minimal Breaking Changes)

1. **Accept the dialyzer warnings** as a known limitation
2. **Document the type safety limitations** clearly
3. **Provide dialyzer ignore configuration** for users
4. **Fix the immediate issues** (opts types, callback arguments)

### Long Term (Breaking Changes Acceptable)

Adopt **Solution 1: Single Struct Type** because:

1. **Least disruptive** to current API
2. **Achieves full type safety**
3. **Maintains agent identity** via module field
4. **Simple to implement and understand**

Implementation would involve:
1. Remove struct generation from macro
2. Add `__module__` field to base struct
3. Update all type specs to use `Jido.Agent.t()`
4. Modify dispatch to use `agent.__module__` instead of `agent.__struct__`

### Alternative: Embrace the Framework Pattern

If breaking changes are unacceptable, formally adopt a "framework pattern":

1. **Acknowledge dialyzer limitations** in documentation
2. **Provide official dialyzer suppressions**
3. **Focus on runtime correctness** over static analysis
4. **Position as a dynamic framework** (like Phoenix, which also has some dialyzer challenges)

## Conclusion

The Jido framework's type system issues stem from attempting to implement inheritance-like patterns in a language designed for composition and protocols. While the runtime behavior is correct, the static type analysis cannot verify this correctness due to fundamental mismatches between the framework's design patterns and Elixir's type system.

The recommended path forward is to embrace Elixir's strengths by either:
1. Using a single struct type with module-based dispatch (recommended)
2. Accepting the current limitations and providing good tooling to suppress warnings

Both approaches are valid depending on the framework's priorities regarding type safety versus API design.
</file>

<file path="migration_strategy_guide.md">
# Migration Strategy Guide: From Traditional Elixir to Type-Safe Perimeters

## Overview

This guide provides a comprehensive strategy for migrating existing Elixir applications to use the "Defensive Perimeter / Offensive Interior" pattern. The migration is designed to be gradual, allowing teams to adopt type contracts incrementally while maintaining system stability.

## Migration Phases

### Phase 0: Assessment and Planning

Before beginning migration, assess your current codebase:

```elixir
defmodule MigrationAssessment do
  @moduledoc """
  Tools to assess codebase readiness for type contract migration.
  """
  
  def analyze_project(app_name) do
    modules = get_all_modules(app_name)
    
    %{
      total_modules: length(modules),
      actions: count_pattern(modules, &uses?(&1, Jido.Action)),
      agents: count_pattern(modules, &uses?(&1, Jido.Agent)),
      genservers: count_pattern(modules, &uses?(&1, GenServer)),
      phoenix_controllers: count_pattern(modules, &uses?(&1, Phoenix.Controller)),
      perimeter_candidates: identify_perimeter_modules(modules),
      antipattern_risks: scan_for_antipatterns(modules)
    }
  end
  
  defp identify_perimeter_modules(modules) do
    modules
    |> Enum.filter(&is_perimeter_module?/1)
    |> Enum.map(&module_info/1)
  end
  
  defp is_perimeter_module?(module) do
    # Modules that interact with external systems
    exports = module.__info__(:functions)
    
    Enum.any?(exports, fn {name, _arity} ->
      name in [:run, :call, :handle_call, :create, :update, :delete]
    end)
  end
end
```

### Phase 1: Infrastructure Setup

#### Step 1: Add Dependencies

```elixir
# mix.exs
defp deps do
  [
    # Existing deps...
    {:jido_type_enforcement, "~> 1.0"},
    {:jido_perimeter_guard, "~> 1.0"},
    
    # Development tools
    {:perimeter, "~> 0.10", runtime: false},
    {:credo_type_check, "~> 1.0", only: [:dev, :test]}
  ]
end
```

#### Step 2: Configure Type Enforcement

```elixir
# config/config.exs
config :jido_type_enforcement,
  default_level: :log,  # Start with logging only
  telemetry_enabled: true,
  cache_size: 1000

# config/dev.exs  
config :jido_type_enforcement,
  default_level: :warn  # Stricter in development

# config/test.exs
config :jido_type_enforcement,
  default_level: :strict  # Strict in tests
```

#### Step 3: Create Migration Helpers

```elixir
defmodule MyApp.TypeMigration do
  @moduledoc """
  Helpers for gradual type contract migration.
  """
  
  defmacro __using__(opts) do
    level = Keyword.get(opts, :level, :log)
    
    quote do
      use Jido.PerimeterGuard, enforcement: unquote(level)
      use Jido.TypeContract
      
      # Migration helper to wrap existing functions
      defmacro migrate_function(name, arity, contract) do
        quote do
          original = :"__original_#{unquote(name)}"
          
          # Rename original function
          defdelegate unquote(original)(var!(args)), to: __MODULE__, as: unquote(name)
          
          # Create wrapper with validation
          def unquote(name)(args) do
            case validate_contract(unquote(contract), args) do
              {:ok, validated} ->
                apply(__MODULE__, unquote(original), [validated])
              {:error, violations} ->
                MyApp.TypeMigration.handle_violation(violations, unquote(level))
                apply(__MODULE__, unquote(original), [args])
            end
          end
        end
      end
    end
  end
end
```

### Phase 2: Identify and Migrate Perimeters

#### Step 1: Start with External Interfaces

Priority order for migration:

1. **HTTP/API Controllers**
```elixir
defmodule MyAppWeb.UserController do
  use MyAppWeb, :controller
  use MyApp.TypeMigration, level: :log
  
  # Before: No validation
  def create(conn, params) do
    case Users.create_user(params["user"]) do
      {:ok, user} -> json(conn, user)
      {:error, _} -> send_resp(conn, 422, "Error")
    end
  end
  
  # After: With contract
  defcontract :create_params do
    required :user, :map do
      required :email, :string
      required :password, :string
      optional :name, :string
    end
  end
  
  @guard function: :create, input: :create_params
  def create(conn, params) do
    # Same implementation, but params are validated
    case Users.create_user(params.user) do
      {:ok, user} -> json(conn, user)
      {:error, _} -> send_resp(conn, 422, "Error")
    end
  end
end
```

2. **GenServer Interfaces**
```elixir
defmodule MyApp.DataProcessor do
  use GenServer
  use MyApp.TypeMigration, level: :warn
  
  defcontract :process_request do
    required :type, :atom, in: [:sync, :async]
    required :data, :map
    optional :options, :keyword_list
  end
  
  # Migrate handle_call
  def handle_call({:process, request}, from, state) do
    case validate_contract(:process_request, request) do
      {:ok, valid_request} ->
        do_process(valid_request, from, state)
      {:error, violations} ->
        {:reply, {:error, format_violations(violations)}, state}
    end
  end
end
```

#### Step 2: Migrate Internal Perimeters

Focus on module perimeters that cross contexts:

```elixir
defmodule MyApp.Accounts do
  use MyApp.TypeMigration
  
  # Define contracts for context perimeters
  defcontract :create_user_attrs do
    required :email, :string
    required :password, :string
    optional :profile, :map do
      optional :name, :string
      optional :bio, :string
    end
  end
  
  # Original function
  def create_user(attrs) do
    # Existing implementation
  end
  
  # Add validated version alongside
  @guard function: :create_user_validated, input: :create_user_attrs
  def create_user_validated(attrs) do
    create_user(attrs)  # Delegates to original
  end
  
  # Gradually update callers to use validated version
}
```

### Phase 3: Address Antipatterns

#### Fix Non-Assertive Map Access

```elixir
defmodule AntipatternFixes do
  # Before: Non-assertive access
  def process_user(user) do
    name = user[:name] || "Unknown"
    email = user[:email]
    age = user[:age]
    
    # Process with possibly nil values
  end
  
  # After: Contract-enforced structure
  defcontract :user do
    required :email, :string
    optional :name, :string, default: "Unknown"
    optional :age, :integer
  end
  
  @guard input: :user
  def process_user(user) do
    # Assertive access - we know email exists
    %{email: email, name: name} = user
    age = user[:age]  # Still optional
    
    # Process with guaranteed structure
  end
end
```

#### Fix Dynamic Atom Creation

```elixir
defmodule AtomSafetyMigration do
  # Before: Dangerous dynamic atom creation
  def process_status(status_string) do
    String.to_atom(status_string)
  end
  
  # After: Safe with explicit mapping
  defcontract :status_update do
    required :status, :string, in: ~w(active inactive pending banned)
  end
  
  @guard input: :status_update
  def process_status(%{status: status_string}) do
    # Safe mapping to existing atoms
    case status_string do
      "active" -> :active
      "inactive" -> :inactive
      "pending" -> :pending
      "banned" -> :banned
    end
  end
end
```

### Phase 4: Incremental Enforcement

#### Step 1: Monitor and Measure

```elixir
defmodule MigrationMonitor do
  use GenServer
  
  def init(_) do
    :telemetry.attach(
      "migration-monitor",
      [:jido, :perimeter, :violation],
      &handle_violation/4,
      nil
    )
    
    {:ok, %{violations: %{}, start_time: System.monotonic_time()}}
  end
  
  def handle_violation(_event, measurements, metadata, _config) do
    GenServer.cast(__MODULE__, {:violation, metadata.module, metadata.violation})
  end
  
  def report do
    GenServer.call(__MODULE__, :report)
  end
  
  def handle_call(:report, _from, state) do
    report = %{
      total_violations: count_violations(state.violations),
      by_module: top_violators(state.violations),
      by_type: violation_types(state.violations),
      uptime: System.monotonic_time() - state.start_time
    }
    
    {:reply, report, state}
  end
end
```

#### Step 2: Gradual Enforcement Increase

```elixir
defmodule EnforcementScheduler do
  @moduledoc """
  Gradually increases enforcement levels based on violation metrics.
  """
  
  def schedule_enforcement_increase(app) do
    # Week 1-2: Log only
    set_all_modules_enforcement(app, :log)
    
    # Week 3-4: Warn on violations
    :timer.apply_after(:timer.weeks(2), __MODULE__, :increase_enforcement, [app, :warn])
    
    # Week 5-6: Strict for specific modules
    :timer.apply_after(:timer.weeks(4), __MODULE__, :selective_strict, [app])
    
    # Week 7+: Full strict mode
    :timer.apply_after(:timer.weeks(6), __MODULE__, :increase_enforcement, [app, :strict])
  end
  
  def selective_strict(app) do
    # Start with least critical modules
    safe_modules = identify_safe_modules(app)
    
    Enum.each(safe_modules, fn module ->
      Jido.TypeEnforcement.set_module_level(module, :strict)
    end)
  end
end
```

### Phase 5: Team Migration Patterns

#### Pattern 1: The Strangler Fig

Wrap old implementations with new contract-based interfaces:

```elixir
defmodule LegacyWrapper do
  use Jido.TypeContract
  
  # Old module we're replacing
  alias MyApp.LegacyUserService
  
  defcontract :user_input do
    required :username, :string
    required :email, :string
    optional :metadata, :map
  end
  
  # New interface with contracts
  @guard input: :user_input
  def create_user(params) do
    # Transform to legacy format
    legacy_params = %{
      "user_name" => params.username,
      "user_email" => params.email,
      "extra" => params[:metadata] || %{}
    }
    
    # Call legacy service
    case LegacyUserService.create(legacy_params) do
      {:ok, user} -> {:ok, transform_legacy_user(user)}
      error -> error
    end
  end
  
  # Gradually move logic from legacy to new module
end
```

#### Pattern 2: The Branch by Abstraction

Create abstraction layer for gradual migration:

```elixir
defmodule AbstractionLayer do
  @callback validate_input(map()) :: {:ok, map()} | {:error, term()}
  @callback process(map()) :: {:ok, term()} | {:error, term()}
  
  defmodule LegacyImpl do
    @behaviour AbstractionLayer
    
    def validate_input(input), do: {:ok, input}  # No validation
    def process(input), do: MyApp.LegacyProcessor.run(input)
  end
  
  defmodule ContractImpl do
    @behaviour AbstractionLayer
    use Jido.TypeContract
    
    defcontract :input do
      required :data, :map
      required :format, :atom
    end
    
    def validate_input(input) do
      validate_contract(:input, input)
    end
    
    def process(input) do
      # New implementation
    end
  end
  
  # Switch implementations via config
  def impl do
    Application.get_env(:my_app, :processor_impl, LegacyImpl)
  end
end
```

### Phase 6: Tooling and Automation

#### Custom Mix Tasks

```elixir
defmodule Mix.Tasks.TypeMigration.Status do
  use Mix.Task
  
  @shortdoc "Shows type migration status"
  
  def run(_args) do
    Mix.Task.run("compile")
    
    report = analyze_migration_status()
    
    Mix.shell().info("""
    Type Migration Status
    ====================
    
    Total Modules: #{report.total_modules}
    Migrated: #{report.migrated_count} (#{report.migrated_percentage}%)
    In Progress: #{report.in_progress_count}
    Not Started: #{report.not_started_count}
    
    Enforcement Levels:
    - Strict: #{report.strict_count}
    - Warn: #{report.warn_count}
    - Log: #{report.log_count}
    
    Recent Violations: #{report.recent_violations}
    
    Next Steps:
    #{format_next_steps(report)}
    """)
  end
end
```

#### CI/CD Integration

```yaml
# .github/workflows/type-safety.yml
name: Type Safety Checks

on: [push, pull_request]

jobs:
  type-checks:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Run type contract tests
        run: |
          mix test --only contract_test
          
      - name: Check migration progress
        run: |
          mix type_migration.status --format json > migration-status.json
          
      - name: Validate no new violations
        run: |
          mix type_migration.check --baseline .type-baseline.json
          
      - name: Generate coverage report
        run: |
          mix type_migration.coverage --min 80
```

### Migration Timeline Example

```elixir
defmodule MigrationTimeline do
  @timeline [
    {0, "Setup infrastructure, add dependencies"},
    {1, "Migrate external APIs (controllers, webhooks)"},
    {2, "Migrate GenServers and process perimeters"},
    {3, "Fix non-assertive patterns in critical paths"},
    {4, "Migrate internal module perimeters"},
    {5, "Address remaining antipatterns"},
    {6, "Increase enforcement to :warn"},
    {8, "Selective :strict enforcement"},
    {10, "Full :strict mode in production"},
    {12, "Remove migration helpers"}
  ]
  
  def weeks_to_complete(module_count) do
    base_weeks = 12
    scaling_factor = module_count / 100
    
    base_weeks + (scaling_factor * 2)
  }
}
```

## Post-Migration Best Practices

### 1. Maintain Type Contracts

```elixir
defmodule ContractMaintenance do
  # Regular contract review
  def review_contracts do
    all_contracts()
    |> Enum.filter(&contract_unused?/1)
    |> Enum.each(&log_unused_contract/1)
  end
  
  # Contract versioning for API evolution
  defcontract :api_v1 do
    required :data, :map
  end
  
  defcontract :api_v2 do
    required :data, :map
    required :version, :integer
    optional :metadata, :map
  end
end
```

### 2. Performance Monitoring

```elixir
defmodule PerformanceMonitor do
  def setup do
    :telemetry.attach_many(
      "type-performance",
      [
        [:jido, :type, :validation, :start],
        [:jido, :type, :validation, :stop]
      ],
      &handle_event/4,
      nil
    )
  end
  
  def handle_event([:jido, :type, :validation, :stop], measurements, metadata, _) do
    duration = measurements.duration
    
    if duration > :timer.milliseconds(10) do
      Logger.warning("Slow validation: #{metadata.contract} took #{duration}μs")
    end
  end
end
```

## Conclusion

Successful migration to type-safe perimeters requires:

1. **Gradual Approach**: Start with logging, increase enforcement over time
2. **Team Buy-in**: Education and clear benefits demonstration
3. **Tool Support**: Automation and monitoring
4. **Clear Patterns**: Consistent approaches to common scenarios
5. **Measurement**: Track progress and adjust strategy

The migration process typically takes 3-6 months for medium-sized applications, but results in:
- Fewer runtime errors
- Better documentation through contracts
- Easier onboarding for new developers
- More confident refactoring
- Clear system perimeters
</file>

<file path="PERIMETER_CACHING_STRATEGIES.md">
# Perimeter Library Caching Strategies

## Overview

This document outlines caching strategies for the `perimeter` library to ensure minimal performance overhead while maintaining correctness. The caching system is designed to optimize repeated validations without sacrificing the safety guarantees of the defensive perimeter pattern.

## Core Caching Principles

### 1. Immutability Advantage
Elixir's immutable data structures make caching particularly effective:
- Once validated, a data structure cannot change
- Cache keys can be based on data identity
- No cache invalidation needed for validated data

### 2. Compile-Time vs Runtime Caching
The library employs both strategies:
- **Compile-time**: Contract compilation and optimization
- **Runtime**: Validation result caching

### 3. Memory vs CPU Trade-off
Caching decisions balance:
- Memory usage (storing validation results)
- CPU usage (recomputing validations)
- Cache lookup overhead

## Compile-Time Caching Strategies

### 1. Contract Compilation Cache

```elixir
defmodule Perimeter.Contract.Compiler do
  @moduledoc """
  Compiles contracts into optimized validation functions at compile time.
  """
  
  defmacro compile_contract(contract_definition) do
    # Generate optimized validator at compile time
    validator_ast = build_optimized_validator(contract_definition)
    
    quote do
      # Store compiled validator as module attribute
      @compiled_validators[unquote(contract_name)] = unquote(Macro.escape(validator_ast))
      
      # Generate fast validator function
      def __fast_validate__(unquote(contract_name), data) do
        unquote(validator_ast)
      end
    end
  end
  
  defp build_optimized_validator(contract) do
    # Convert contract to optimized pattern matches
    # This runs at compile time, not runtime
    quote do
      case data do
        %{unquote_splicing(required_field_patterns(contract))} ->
          # Inline type checks
          unquote(generate_type_checks(contract))
        _ ->
          {:error, :missing_required_fields}
      end
    end
  end
end
```

### 2. Pattern Match Optimization

```elixir
defmodule Perimeter.Contract.PatternOptimizer do
  @moduledoc """
  Optimizes contracts into efficient pattern matches.
  """
  
  def optimize_contract(contract) do
    contract
    |> group_by_type()
    |> generate_type_specific_validators()
    |> compile_to_beam_friendly_form()
  end
  
  # Group fields by type for batch validation
  defp group_by_type(contract) do
    contract.fields
    |> Enum.group_by(& &1.type)
    |> Enum.map(fn {type, fields} ->
      {type, optimize_type_check(type, fields)}
    end)
  end
  
  # Generate specialized validators per type
  defp optimize_type_check(:string, fields) do
    # Single pass string validation for all string fields
    quote do
      Enum.all?(unquote(fields), fn field ->
        is_binary(Map.get(data, field.name))
      end)
    end
  end
end
```

## Runtime Caching Strategies

### 1. Validation Result Cache

```elixir
defmodule Perimeter.Cache do
  @moduledoc """
  ETS-based cache for validation results with configurable TTL.
  """
  
  use GenServer
  
  @table_name :perimeter_validation_cache
  @default_ttl :infinity
  @max_cache_size 10_000
  
  def start_link(opts) do
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end
  
  def init(opts) do
    table = :ets.new(@table_name, [
      :set,
      :public,
      :named_table,
      {:read_concurrency, true},
      {:write_concurrency, true}
    ])
    
    state = %{
      table: table,
      ttl: Keyword.get(opts, :ttl, @default_ttl),
      max_size: Keyword.get(opts, :max_size, @max_cache_size),
      size: 0,
      hits: 0,
      misses: 0
    }
    
    {:ok, state}
  end
  
  @doc """
  Cache-aware validation with TTL support.
  """
  def validate_with_cache(module, contract, data, opts \ []) do
    cache_key = compute_cache_key(module, contract, data)
    
    case lookup_cache(cache_key) do
      {:ok, cached_result} ->
        bump_stats(:hit)
        cached_result
        
      :miss ->
        bump_stats(:miss)
        result = Perimeter.Validator.validate_direct(module, contract, data)
        cache_result(cache_key, result, opts)
        result
    end
  end
  
  defp compute_cache_key(module, contract, data) do
    # Use :erlang.phash2 for fast, stable hashing
    :erlang.phash2({module, contract, data})
  end
  
  defp lookup_cache(key) do
    case :ets.lookup(@table_name, key) do
      [{^key, result, expiry}] when expiry > System.monotonic_time() ->
        {:ok, result}
      _ ->
        :miss
    end
  end
  
  defp cache_result(key, result, opts) do
    ttl = Keyword.get(opts, :ttl, @default_ttl)
    expiry = case ttl do
      :infinity -> :infinity
      ms -> System.monotonic_time() + ms * 1_000_000
    end
    
    GenServer.cast(__MODULE__, {:cache, key, result, expiry})
  end
  
  def handle_cast({:cache, key, result, expiry}, state) do
    # Implement LRU eviction if needed
    state = maybe_evict_entries(state)
    
    :ets.insert(@table_name, {key, result, expiry})
    {:noreply, %{state | size: state.size + 1}}
  end
  
  defp maybe_evict_entries(%{size: size, max_size: max} = state) when size >= max do
    # Simple FIFO eviction for now
    # Could implement LRU with additional timestamp tracking
    oldest_key = :ets.first(@table_name)
    :ets.delete(@table_name, oldest_key)
    %{state | size: size - 1}
  end
  defp maybe_evict_entries(state), do: state
end
```

### 2. Partial Validation Cache

```elixir
defmodule Perimeter.Cache.Partial do
  @moduledoc """
  Caches validation results for parts of nested structures.
  """
  
  def validate_with_partial_cache(data, contract) do
    case data do
      %{__cached_validation__: token} ->
        # Check if this exact data was already validated
        lookup_validation_token(token)
        
      map when is_map(map) ->
        # Check cache for each nested structure
        validate_with_nested_cache(map, contract)
        
      _ ->
        # No caching for non-map data
        Perimeter.Validator.validate_direct(data, contract)
    end
  end
  
  defp validate_with_nested_cache(map, contract) do
    # Validate nested structures independently
    Enum.reduce_while(contract.fields, {:ok, %{}}, fn field, {:ok, acc} ->
      case validate_field_with_cache(map, field) do
        {:ok, value} ->
          {:cont, {:ok, Map.put(acc, field.name, value)}}
        {:error, _} = error ->
          {:halt, error}
      end
    end)
  end
end
```

### 3. Contract-Specific Caching

```elixir
defmodule Perimeter.Cache.ContractSpecific do
  @moduledoc """
  Provides contract-specific caching strategies.
  """
  
  defmacro enable_caching(contract_name, opts \ []) do
    strategy = Keyword.get(opts, :strategy, :full)
    ttl = Keyword.get(opts, :ttl, :timer.minutes(5))
    
    quote do
      @contract_cache_config[unquote(contract_name)] = %{
        strategy: unquote(strategy),
        ttl: unquote(ttl),
        enabled: true
      }
    end
  end
  
  # Different caching strategies per contract
  def cache_strategy(module, contract_name) do
    config = module.__contract_cache_config__(contract_name)
    
    case config.strategy do
      :full ->
        # Cache entire validation result
        &full_result_cache/3
        
      :fields ->
        # Cache individual field validations
        &field_level_cache/3
        
      :none ->
        # No caching for this contract
        &no_cache/3
    end
  end
end
```

## Cache Key Strategies

### 1. Content-Based Keys

```elixir
defmodule Perimeter.Cache.Keys do
  @moduledoc """
  Efficient cache key generation strategies.
  """
  
  # Fast hash for immutable data
  def content_hash(data) when is_map(data) do
    :erlang.phash2(data)
  end
  
  # Structural hash (ignores values, only structure)
  def structural_hash(data) when is_map(data) do
    data
    |> Map.keys()
    |> Enum.sort()
    |> :erlang.phash2()
  end
  
  # Hybrid approach for large data
  def smart_hash(data) when is_map(data) do
    if map_size(data) > 100 do
      # For large maps, hash structure + sample values
      sample_hash(data)
    else
      # For small maps, hash everything
      content_hash(data)
    end
  end
  
  defp sample_hash(data) do
    # Hash structure + first N values
    keys = Map.keys(data) |> Enum.sort() |> Enum.take(10)
    sample = Enum.map(keys, &{&1, Map.get(data, &1)})
    :erlang.phash2({keys, sample})
  end
end
```

### 2. Hierarchical Cache Keys

```elixir
defmodule Perimeter.Cache.Hierarchical do
  @moduledoc """
  Hierarchical caching for nested validations.
  """
  
  def build_cache_hierarchy(data, path \ []) do
    case data do
      map when is_map(map) ->
        # Build hierarchy of cache keys
        Enum.map(map, fn {key, value} ->
          child_path = path ++ [key]
          {
            cache_key: path_to_cache_key(child_path),
            value: value,
            children: build_cache_hierarchy(value, child_path)
          }
        end)
        
      list when is_list(list) ->
        # Cache list validations separately
        {
          cache_key: path_to_cache_key(path ++ [:__list__]),
          items: Enum.with_index(list)
        }
        
      _ ->
        nil
    end
  end
  
  defp path_to_cache_key(path) do
    :erlang.phash2(path)
  end
end
```

## Cache Warming Strategies

### 1. Compile-Time Warming

```elixir
defmodule Perimeter.Cache.Warming do
  @moduledoc """
  Pre-warm caches with common validations.
  """
  
  defmacro warm_cache(contract_name, examples) do
    quote do
      @on_load :warm_validation_cache
      
      def warm_validation_cache do
        # Validate examples at module load time
        Enum.each(unquote(examples), fn example ->
          Perimeter.Validator.validate(__MODULE__, unquote(contract_name), example)
        end)
        :ok
      end
    end
  end
end

# Usage
defmodule MyModule do
  use Perimeter.Contract
  
  defcontract :user do
    required :email, :string
    required :age, :integer
  end
  
  # Pre-validate common cases
  warm_cache :user, [
    %{email: "admin@example.com", age: 30},
    %{email: "user@example.com", age: 25}
  ]
end
```

### 2. Runtime Cache Warming

```elixir
defmodule Perimeter.Cache.RuntimeWarming do
  @moduledoc """
  Warms cache based on actual usage patterns.
  """
  
  use GenServer
  
  def start_link(opts) do
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end
  
  def init(_opts) do
    # Track validation patterns
    :ets.new(:perimeter_usage_patterns, [:set, :public, :named_table])
    
    # Periodically analyze and warm cache
    schedule_analysis()
    
    {:ok, %{}}
  end
  
  def track_validation(module, contract, data) do
    pattern = extract_pattern(data)
    :ets.update_counter(:perimeter_usage_patterns, {module, contract, pattern}, 1, {{module, contract, pattern}, 0})
  end
  
  defp extract_pattern(data) when is_map(data) do
    # Extract structural pattern
    data
    |> Map.keys()
    |> Enum.sort()
  end
  
  def handle_info(:analyze_patterns, state) do
    warm_frequent_patterns()
    schedule_analysis()
    {:noreply, state}
  end
  
  defp warm_frequent_patterns do
    :ets.tab2list(:perimeter_usage_patterns)
    |> Enum.filter(fn {{_mod, _contract, _pattern}, count} -> count > 100 end)
    |> Enum.each(fn {{mod, contract, pattern}, _count} ->
      # Generate and validate synthetic data matching pattern
      synthetic_data = generate_from_pattern(pattern)
      Perimeter.Validator.validate(mod, contract, synthetic_data)
    end)
  end
end
```

## Cache Invalidation Strategies

### 1. TTL-Based Invalidation

```elixir
defmodule Perimeter.Cache.TTL do
  @moduledoc """
  Time-based cache invalidation.
  """
  
  def cleanup_expired_entries do
    now = System.monotonic_time()
    
    # ETS match spec for expired entries
    match_spec = [
      {
        {:_,"$2",:"$3"},
        [{:<, :"$3", now}],
        [:"$1"]
      }
    ]
    
    expired_keys = :ets.select(:perimeter_validation_cache, match_spec)
    Enum.each(expired_keys, &:ets.delete(:perimeter_validation_cache, &1))
  end
  
  # Run periodically
  def schedule_cleanup do
    Process.send_after(self(), :cleanup, :timer.minutes(5))
  end
end
```

### 2. Memory-Pressure Invalidation

```elixir
defmodule Perimeter.Cache.MemoryPressure do
  @moduledoc """
  Responds to memory pressure by evicting cache entries.
  """
  
  def check_memory_pressure do
    case :erlang.memory(:total) do
      bytes when bytes > memory_threshold() ->
        evict_percentage(0.2) # Evict 20% of cache
        
      _ ->
        :ok
    end
  end
  
  defp memory_threshold do
    # 80% of system memory
    :erlang.system_info(:system_total_memory) * 0.8
  end
  
  defp evict_percentage(percent) do
    cache_size = :ets.info(:perimeter_validation_cache, :size)
    to_evict = trunc(cache_size * percent)
    
    # Evict oldest entries first
    :ets.foldl(
      fn entry, count when count < to_evict ->
        :ets.delete(:perimeter_validation_cache, elem(entry, 0))
        count + 1
      end,
      0,
      :perimeter_validation_cache
    )
  end
end
```

## Performance Monitoring

### 1. Cache Metrics

```elixir
defmodule Perimeter.Cache.Metrics do
  @moduledoc """
  Telemetry integration for cache monitoring.
  """
  
  def emit_cache_metrics do
    metrics = %{
      size: :ets.info(:perimeter_validation_cache, :size),
      memory: :ets.info(:perimeter_validation_cache, :memory),
      hit_rate: calculate_hit_rate(),
      avg_lookup_time: calculate_avg_lookup_time()
    }
    
    :telemetry.execute(
      [:perimeter, :cache, :snapshot],
      metrics,
      %{}
    )
  end
  
  def track_lookup(key, result, duration) do
    :telemetry.execute(
      [:perimeter, :cache, :lookup],
      %{duration: duration},
      %{key: key, result: result}
    )
  end
end
```

### 2. Adaptive Caching

```elixir
defmodule Perimeter.Cache.Adaptive do
  @moduledoc """
  Adapts caching strategy based on runtime metrics.
  """
  
  def should_cache?(module, contract, data_size) do
    stats = get_contract_stats(module, contract)
    
    # Cache if frequently validated or expensive
    stats.validation_count > 10 or
    stats.avg_validation_time > 1000 or  # 1ms
    data_size > 50  # Large data structures
  end
  
  def adjust_ttl(module, contract) do
    stats = get_contract_stats(module, contract)
    
    cond do
      # High frequency, long TTL
      stats.validations_per_minute > 100 ->
        :timer.hours(1)
        
      # Medium frequency
      stats.validations_per_minute > 10 ->
        :timer.minutes(10)
        
      # Low frequency, short TTL
      true ->
        :timer.minutes(1)
    end
  end
end
```

## Configuration Options

```elixir
# config/config.exs
config :perimeter,
  cache: [
    enabled: true,
    strategy: :ets,  # :ets | :persistent_term | :none
    max_size: 10_000,
    default_ttl: :timer.minutes(5),
    cleanup_interval: :timer.minutes(1),
    warm_cache_on_boot: true,
    compression: false  # Compress large cached values
  ]

# Per-environment configuration
config :perimeter, :prod,
  cache: [
    strategy: :persistent_term,  # Better for read-heavy production
    compression: true
  ]

config :perimeter, :test,
  cache: [
    enabled: false  # Disable caching in tests for predictability
  ]
```

## Best Practices

### 1. Cache Selection Guidelines

- **Always Cache**: Small, frequently validated contracts
- **Sometimes Cache**: Large data with expensive validations
- **Never Cache**: Contracts with time-sensitive validations

### 2. Memory Management

- Set reasonable TTLs based on usage patterns
- Monitor cache size and hit rates
- Implement memory-pressure responses
- Use compression for large cached values

### 3. Testing Considerations

- Disable caching in test environment by default
- Provide cache bypass options for debugging
- Test cache eviction strategies
- Verify cache correctness with property tests

## Summary

The caching strategy for `perimeter` leverages Elixir's immutability to provide efficient validation caching without sacrificing correctness. By combining compile-time optimization with runtime result caching, the library achieves minimal overhead while maintaining the strong guarantees of the defensive perimeter pattern.
</file>

<file path="PERIMETER_gem_0001.md">
Of course. This is an excellent idea. The "Defensive Perimeter / Offensive Interior" pattern is a powerful, reusable concept. I will structure this as a new library called `Perimeter`.

Here are the key documentation files for the `Perimeter` library, which directly reference and build upon the philosophy outlined in your 20250702 documents.

---

### `mix.exs`

```elixir
defmodule Perimeter.MixProject do
  use Mix.Project

  def project do
    [
      app: :perimeter,
      version: "0.1.0",
      elixir: "~> 1.13",
      start_permanent: Mix.env() == :prod,
      deps: deps(),
      description: "A library for defining and enforcing type contracts at your Elixir application's perimeters.",
      package: [
        maintainers: ["Your Name"],
        licenses: ["Apache-2.0"],
        links: %{"GitHub" => "https://github.com/your-org/perimeter"}
      ]
    ]
  end

  def application do
    [
      extra_applications: [:logger]
    ]
  end

  defp deps do
    [
      {:dialyxir, "~> 1.0", only: [:dev], runtime: false},
      {:credo, "~> 1.6", only: [:dev, :test], runtime: false},
      {:ex_doc, "~> 0.28", only: :dev, runtime: false}
    ]
  end
end
```

---

### `README.md`

# Perimeter

[![Hex.pm](https://img.shields.io/hexpm/v/perimeter.svg)](https://hex.pm/packages/perimeter)
[![CI](https://github.com/your-org/perimeter/actions/workflows/ci.yml/badge.svg)](https://github.com/your-org/perimeter/actions/workflows/ci.yml)

**A library for defining and enforcing explicit type contracts at your Elixir application's perimeters.**

Perimeter allows you to embrace Elixir's dynamic nature and metaprogramming power while providing strong, runtime guarantees where they matter most: at the edge of your system.

It is the public implementation of the **"Defensive Perimeter / Offensive Interior"** pattern, designed to solve the challenges of type safety in complex, metaprogramming-heavy frameworks.

## Key Features

*   **Declarative Contracts:** Define the "shape" of your data using a simple, powerful `defcontract` DSL.
*   **Perimeter Guards:** Enforce contracts at function perimeters with a single `@guard` attribute.
*   **Gradual Enforcement:** Start with logging (`:log`), move to warnings (`:warn`), and finally to strict enforcement (`:strict`), allowing for safe, incremental adoption in existing codebases.
*   **Structured Errors:** Get detailed, structured error information on contract violations.
*   **Anti-Pattern Avoidance:** Encourages best practices and helps eliminate common Elixir anti-patterns.
*   **Performance Conscious:** Designed for minimal overhead with compile-time optimizations and configurable runtime behavior.

## Installation

Add `perimeter` to your list of dependencies in `mix.exs`:

```elixir
def deps do
  [
    {:perimeter, "~> 0.1.0"}
  ]
end
```

## Quick Start

Let's guard a Phoenix controller action.

```elixir
# lib/my_app_web/controllers/user_controller.ex
defmodule MyAppWeb.UserController do
  use MyAppWeb, :controller
  use Perimeter # Imports Perimeter.Contract and Perimeter.Guard

  # 1. Define the contract for incoming parameters.
  defcontract :create_user_params do
    required :user, :map do
      required :email, :string, format: ~r/@/
      required :password, :string, min_length: 8
      optional :name, :string
    end
  end

  # 2. Guard the controller action with the contract.
  @guard input: :create_user_params
  def create(conn, params) do
    # 3. Inside the guarded function, you can trust your data.
    # This is the "Offensive Interior". Use assertive access!
    # No more defensive `get_in`, `||`, or `case`.
    user_attrs = params.user

    case Accounts.create_user(user_attrs) do
      {:ok, user} ->
        conn
        |> put_status(:created)
        |> render("show.json", user: user)

      {:error, %Ecto.Changeset{} = changeset} ->
        conn
        |> put_status(:unprocessable_entity)
        |> render("error.json", changeset: changeset)
    end
  end

  # Perimeter will automatically handle invalid requests.
  # If the contract is violated, it will return a structured
  # error, which can be converted to a 422 response by a Plug.
end
```

## The Perimeter Philosophy

Perimeter is built on the **"Defensive Perimeter / Offensive Interior"** design pattern. This pattern acknowledges a fundamental truth of large Elixir systems: trying to achieve perfect static type safety everywhere is often at odds with the language's most powerful features (like metaprogramming).

Instead, we focus our efforts on the perimeters.

1.  **The Defensive Perimeter:** This is the entry point to your module or system (e.g., a controller action, a public API of a context, a GenServer's `handle_call`). Here, we use `Perimeter.Guard` to strictly validate all incoming data against an explicit `Perimeter.Contract`.

2.  **The Transition Layer:** Once data is validated, Perimeter can optionally transform it (e.g., converting string keys to atoms, providing default values). This prepares the data for the interior.

3.  **The Offensive Interior:** This is the body of your guarded function. Inside this trusted zone, you are free to use Elixir's full power. You can use assertive pattern matching (`%{key: val}`), metaprogramming, and dynamic features with confidence, knowing that the data's structure has already been guaranteed by the perimeter guard.

This approach provides the best of both worlds: the robustness of a type-safe system and the flexibility of a dynamic one.

*For a comprehensive analysis of the philosophy and formal type relationships that led to this library, please see the [original Jido Framework Type System design documents (20250702)](./docs20250702/).*

## Solving Common Elixir Anti-Patterns

Perimeter is designed to programmatically guide you away from common anti-patterns.

| Anti-Pattern | How Perimeter Solves It |
| :--- | :--- |
| **Non-Assertive Map Access** | Contracts guarantee the shape of data, allowing you to use assertive `map.key` and `%{key: val}` access inside guarded functions. |
| **Dynamic Atom Creation** | Contracts can validate incoming strings against an explicit list of allowed values, which can then be safely converted to existing atoms. |
| **Complex `else` Clauses in `with`** | Promotes a single, clear validation step at the beginning of a function, simplifying the "happy path" logic within the `with` block. |
| **Long Parameter Lists** | Encourages grouping related parameters into a map that is validated by a single, clear contract. |
| **Non-Assertive Pattern Matching** | By validating the data shape at the perimeter, you can write assertive, non-defensive code in the function interior, letting it crash on unexpected (and now truly exceptional) data shapes. |

---

### `lib/perimeter.ex`

```elixir
defmodule Perimeter do
  @moduledoc """
  The main entry point for the Perimeter library.

  Provides a `use Perimeter` macro to conveniently import the core
  functionality for defining and guarding contracts.

  ## The Perimeter Philosophy

  Perimeter implements the **"Defensive Perimeter / Offensive Interior"**
  design pattern. This pattern advocates for strict, explicit data validation at
  the perimeters of your system, which in turn allows for more flexible,
  assertive, and dynamic code within those perimeters.

  The core workflow is:
  1. **`use Perimeter`** to bring in the necessary tools.
  2. **`defcontract/2`** to define the expected shape of your data.
  3. **`@guard/1`** to enforce that contract on a function perimeter.

  By adopting this pattern, you gain runtime type safety where it's most
  critical, without sacrificing the metaprogramming power and flexibility
  that make Elixir productive.

  For a deeper dive into the design philosophy, see the main `README.md` file.
  """

  defmacro __using__(_opts) do
    quote do
      import Perimeter.Contract
      import Perimeter.Guard
    end
  end
end
```

---

### `lib/perimeter/contract.ex`

```elixir
defmodule Perimeter.Contract do
  @moduledoc """
  A DSL for defining declarative data contracts.

  Contracts are defined at compile time and are used by `Perimeter.Guard`
  to validate data at runtime. They serve as both executable validation
  rules and clear documentation for your module's public interface.

  This module is typically imported via `use Perimeter`.
  """

  @doc """
  Defines a contract.

  A contract is a named set of rules that describe the expected shape, types,
  and constraints of a map.

  ## Examples

      defcontract :create_user_params do
        # Fields can be required or optional
        required :email, :string, format: ~r/@/
        optional :name, :string, max_length: 100

        # Fields can be nested maps
        required :profile, :map do
          required :age, :integer, min: 18
          optional :bio, :string
        end

        # Fields can be lists of a specific type
        optional :tags, {:list, :string}

        # You can add custom validation functions
        validate :password_must_be_strong
      end

      defp password_must_be_strong(%{password: pass}) do
        if String.length(pass) >= 12 and String.match?(pass, ~r/\d/) do
          :ok
        else
          {:error, %{field: :password, error: "is not strong enough"}}
        end
      end
  """
  defmacro defcontract(name, do: block) do
    # ... implementation ...
  end

  @doc "Defines a required field within a contract."
  defmacro required(field, type, opts \\ []) do
    # ... implementation ...
  end

  @doc "Defines an optional field within a contract."
  defmacro optional(field, type, opts \\ []) do
    # ... implementation ...
  end

  @doc "Registers a custom validation function for the contract."
  defmacro validate(function_name) do
    # ... implementation ...
  end
end
```

---

### `lib/perimeter/guard.ex`

```elixir
defmodule Perimeter.Guard do
  @moduledoc """
  Enforces contracts at function perimeters.

  The `guard/1` macro wraps a function, creating a "Defensive Perimeter"
  around it. It intercepts the function call, validates the arguments
  against the specified contract, and only executes the original function
  if the data is valid.

  This module is typically imported via `use Perimeter`.
  """

  @doc """
  Guards a function with an input and/or output contract.

  ## Options

  * `:input` - (Required) The name of the contract to validate the first argument against.
  * `:output` - (Optional) The name of the contract to validate the function's return value against.
  * `:enforcement` - (Optional) The enforcement level. Can be `:strict` (default), `:warn`, or `:log`.

  ## Example

      defmodule MyApp.Actions.CreateUser do
        use Perimeter

        defcontract :input_contract do
          required :email, :string
        end

        defcontract :output_contract do
          required :id, :string
          required :user, MyApp.User
        end

        # This guard will validate `params` against :input_contract
        # and the return value of the function against :output_contract.
        @guard input: :input_contract, output: :output_contract
        def run(params, _context) do
          # ... logic ...
          {:ok, %{id: "user-123", user: %MyApp.User{...}}}
        end
      end
  """
  defmacro guard(opts) do
    # ... implementation that wraps the function ...
  end
end
```

---

### `lib/perimeter/error.ex`

```elixir
defmodule Perimeter.Error do
  @moduledoc """
  Defines a structured error for contract violations.

  Instead of returning generic error tuples, Perimeter provides a rich,
  structured error that can be easily inspected, logged, and transformed
  into user-facing error messages (e.g., in an API response).

  This approach is based on the best practices outlined in the
  [Type-Safe Error Handling Guide](docs20250702/error_handling_type_safety.md).
  """

  @type t :: %__MODULE__{
          type: :validation_error,
          message: String.t(),
          violations: list(violation())
        }

  @type violation :: %{
          field: atom(),
          error: String.t(),
          value: any(),
          path: list(atom() | integer())
        }

  defstruct [:type, :message, :violations]

  @doc """
  Creates a new validation error.
  """
  @spec new(list(violation())) :: t()
  def new(violations) do
    %__MODULE__{
      type: :validation_error,
      message: "Input validation failed",
      violations: violations
    }
  end
end
```
</file>

<file path="PERIMETER_gem_0002.md">
Excellent. The next logical document is a detailed **Usage Guide**. This guide will go beyond the `README.md` quick start, providing a step-by-step walkthrough of the library's core features, configuration, and practical application in different scenarios.

This document will be created as `guides/usage_guide.md` within the library's file structure.

---

### `guides/usage_guide.md`

# Perimeter Usage Guide

Welcome to the Perimeter Usage Guide! This document provides a comprehensive walkthrough of the library's features, from initial configuration to advanced contract definition and error handling. For the philosophy behind Perimeter, please see the main `README.md`.

## Table of Contents

1.  [Configuration](#1-configuration)
    *   Enforcement Levels
    *   Environment-Specific Configuration
    *   Overriding Enforcement
2.  [Defining Contracts in Detail](#2-defining-contracts-in-detail)
    *   Field Types and Validators
    *   Nested Contracts
    *   Custom Validations
3.  [Guarding Functions](#3-guarding-functions)
    *   Guarding Inputs and Outputs
    *   How Guards Interact with Function Clauses
4.  [Handling Violations](#4-handling-violations)
    *   The `Perimeter.Error` Struct
    *   Integrating with a Phoenix FallbackController
5.  [Advanced Use Case: Guarding a GenServer](#5-advanced-use-case-guarding-a-genserver)

## 1. Configuration

Perimeter's behavior is configured primarily through **enforcement levels**. This allows you to tailor how strictly contracts are enforced in different environments.

### Enforcement Levels

*   `:strict` (Default): If a contract is violated, the guarded function is **not** executed, and `{:error, %Perimeter.Error{}}` is returned immediately. **Recommended for `test` and `dev` environments.**
*   `:warn`: If a contract is violated, a warning is logged to the console, but the original function **is still executed** with the invalid data. This is useful for introducing Perimeter into an existing codebase without breaking functionality.
*   `:log`: Same as `:warn`, but logs at the `:info` level. Useful for monitoring contract adherence in production without generating excessive noise.

### Environment-Specific Configuration

You can set the global default enforcement level in your `config/config.exs` files.

```elixir
# config/config.exs
# Set a safe default for production.
config :perimeter,
  enforcement_level: :log

# config/dev.exs
# Be strict during development to catch issues early.
config :perimeter,
  enforcement_level: :strict

# config/test.exs
# Always be strict in tests.
config :perimeter,
  enforcement_level: :strict
```

### Overriding Enforcement

You can override the global default for a specific guard using the `:enforcement` option. This is useful for gradually rolling out stricter validation on a per-function basis.

```elixir
defmodule MyApp.LegacyModule do
  use Perimeter

  defcontract :some_data do
    required :id, :integer
  end

  # Even if the global default is :strict, this guard will only log violations.
  @guard input: :some_data, enforcement: :log
  def process_legacy_data(data) do
    # ...
  end
end
```

## 2. Defining Contracts in Detail

Contracts are the heart of Perimeter. They are defined using the `defcontract/2` macro.

### Field Types and Validators

Perimeter provides a rich set of built-in types and validators.

```elixir
defcontract :advanced_contract do
  # Basic types
  required :status, :atom, in: [:active, :pending, :archived]
  required :is_admin, :boolean
  required :priority, :integer, min: 1, max: 5
  required :name, :string, min_length: 2, max_length: 100
  required :email, :string, format: ~r/@/

  # Default values for optional fields
  optional :role, :string, default: "guest"
  optional :retries, :integer, default: 0

  # List validation
  required :tags, {:list, :string}, min_items: 1
  optional :scores, {:list, :integer}
end
```

### Nested Contracts

You can easily define contracts for nested maps and lists of maps.

```elixir
defcontract :order do
  required :order_id, :string
  
  # A nested map contract
  required :customer, :map do
    required :id, :integer
    optional :name, :string
  end

  # A list of nested maps
  required :line_items, {:list, :map}, min_items: 1 do
    required :product_id, :string
    required :quantity, :integer, min: 1
    required :price_cents, :integer, min: 0
  end
end
```

### Custom Validations

For complex business rules, you can add custom validation functions using `validate/1`. The function receives the (partially) validated data and must return `:ok` or an `{:error, details}` tuple.

```elixir
defcontract :event_registration do
  required :start_date, :date
  required :end_date, :date

  # Register a custom validator function
  validate :end_date_after_start_date
end

# The validator function must be defined in the same module.
defp end_date_after_start_date(%{start_date: start, end_date: end}) do
  if Date.compare(end, start) in [:gt, :eq] do
    :ok
  else
    # The error map is passed directly to Perimeter.Error
    {:error, %{field: :end_date, error: "must be on or after the start date"}}
  end
end
```

## 3. Guarding Functions

The `@guard` attribute is the mechanism that enforces your contracts.

### Guarding Inputs and Outputs

*   The `:input` option validates the **first argument** of the function.
*   The `:output` option validates the **return value** of the function.

```elixir
defmodule MyApp.Actions.CreateUser do
  use Perimeter

  # Contract for function input
  defcontract :input do
    required :email, :string
  end

  # Contract for the :ok part of the function output
  defcontract :success_output do
    required :user, MyApp.User
    required :id, :string
  end

  @guard input: :input, output: :success_output
  def run(params, _context) do
    # `params` is guaranteed to match the :input contract.
    case Accounts.create_user(params) do
      {:ok, user} ->
        # This return value will be validated against :success_output
        {:ok, %{user: user, id: user.id}}
      
      {:error, _changeset} = error ->
        # Error tuples are not validated and are passed through.
        error
    end
  end
end
```

### How Guards Interact with Function Clauses

Perimeter guards the function as a whole (`function/arity`). It does not guard individual function clauses. The guard runs **before** any of your function clauses are matched.

This means you can rely on the data structure being valid *before* you pattern match on it.

```elixir
# This contract ensures the `event` key exists and is an atom.
defcontract :event_payload do
  required :event, :atom
  optional :data, :map
end

@guard input: :event_payload
def handle_event(%{event: :user_created, data: user_data}) do
  # This clause will be safely matched for :user_created events.
end

@guard input: :event_payload
def handle_event(%{event: :order_shipped, data: order_data}) do
  # This clause will be safely matched for :order_shipped events.
end

@guard input: :event_payload
def handle_event(_payload) do
  # A catch-all for other valid events.
end
```

## 4. Handling Violations

When a contract is violated in `:strict` mode, your function returns `{:error, %Perimeter.Error{}}`.

### The `Perimeter.Error` Struct

The error struct gives you detailed information about what went wrong.

```elixir
%Perimeter.Error{
  type: :validation_error,
  message: "Input validation failed",
  violations: [
    %{
      field: :email,
      error: "is not a valid string",
      value: 123,
      path: [:user, :email] # The path to the invalid field
    },
    %{
      field: :age,
      error: "must be at least 18",
      value: 17,
      path: [:user, :profile, :age]
    }
  ]
}
```

### Integrating with a Phoenix FallbackController

A `FallbackController` is the idiomatic way to handle errors in a Phoenix JSON API. It's a perfect place to catch `Perimeter.Error` and transform it into a 422 Unprocessable Entity response.

```elixir
# lib/my_app_web/controllers/fallback_controller.ex
defmodule MyAppWeb.FallbackController do
  use MyAppWeb, :controller
  alias Perimeter.Error

  # This clause will catch errors from guarded controller actions.
  def call(conn, {:error, %Error{violations: violations}}) do
    conn
    |> put_status(:unprocessable_entity)
    |> put_view(json: MyAppWeb.ErrorJSON)
    |> render("422.json", errors: format_violations(violations))
  end

  # Fallback for other errors
  def call(conn, {:error, :not_found}) do
    conn
    |> put_status(:not_found)
    |> put_view(json: MyAppWeb.ErrorJSON)
    |> render("404.json", %{})
  end

  # Helper to format violations for the API response
  defp format_violations(violations) do
    for violation <- violations do
      %{
        path: Enum.join(violation.path, "."),
        message: "#{violation.field} #{violation.error}",
        details: "Received value: #{inspect(violation.value)}"
      }
    end
  end
end
```

Then, in your router, tell your API pipeline to use this controller for errors.

```elixir
# lib/my_app_web/router.ex
pipeline :api do
  plug :accepts, ["json"]
  # Add this line to your API pipeline
  plug :action, fallback: MyAppWeb.FallbackController
end
```

## 5. Advanced Use Case: Guarding a GenServer

Perimeter isn't just for web requests. It's a powerful tool for ensuring the internal consistency of stateful processes like GenServers.

```elixir
defmodule MyApp.MetricsServer do
  use GenServer
  use Perimeter

  # Define a contract for the GenServer's state.
  defcontract :state do
    required :status, :atom, in: [:running, :paused]
    required :request_count, :integer, min: 0
    required :error_rates, :map
  end

  def start_link(_opts) do
    GenServer.start_link(__MODULE__, %{}, name: __MODULE__)
  end

  @impl true
  def init(_opts) do
    initial_state = %{status: :running, request_count: 0, error_rates: %{}}
    {:ok, initial_state}
  end

  # --- Public API ---

  defcontract :record_request_params do
    required :path, :string
    required :status_code, :integer
  end

  @guard input: :record_request_params
  def record_request(params) do
    # The `params` are validated before the GenServer call.
    GenServer.cast(__MODULE__, {:record_request, params})
  end

  # --- Server Callbacks ---

  # Guard the state argument in `handle_cast` to ensure it's always valid.
  @guard input: :state
  @impl true
  def handle_cast({:record_request, params}, state) do
    # We can trust that `state` is valid.
    new_state =
      state
      |> Map.update!(:request_count, &(&1 + 1))
      |> update_error_rate(params)

    # Returning a new state from here will NOT be automatically validated,
    # so we should be careful. Or, we can validate it manually.
    {:noreply, new_state}
  end

  # Guard for a call to ensure a valid state before replying.
  @guard input: :state
  @impl true
  def handle_call(:get_status, _from, state) do
    {:reply, state.status, state}
  end
end
```
</file>

<file path="PERIMETER_gem_0003.md">
Excellent. Let's continue by creating the final two key documents for the library: a guide on **Best Practices and Anti-Patterns** and a guide for **Testing**. These documents will solidify the library's philosophy and provide users with actionable advice for success.

---

### `guides/best_practices.md`

# Best Practices & Anti-Patterns

This guide covers recommended best practices for using the `Perimeter` library effectively. Following these patterns will help you write code that is clear, maintainable, and robust, while avoiding common pitfalls.

This guide is a practical application of the principles found in the [Type Contract Best Practices document (20250702)](../../docs20250702/type_contract_best_practices.md).

## Table of Contents

1.  [Contract Best Practices](#1-contract-best-practices)
    *   Be Explicit and Semantic
    *   Compose, Don't Repeat
    *   Separate Validation from Business Logic
2.  [Guard Best Practices](#2-guard-best-practices)
    *   Guard at the System Perimeter
    *   Trust the Interior
3.  [Common Anti-Patterns to Avoid](#3-common-anti-patterns-to-avoid)
    *   Anti-Pattern: The Chain of Guards
    *   Anti-Pattern: The Overly-Complex Custom Validator
    *   Anti-Pattern: The Anemic Contract
    *   Anti-Pattern: Bypassing the Guard

## 1. Contract Best Practices

### Be Explicit and Semantic

Your contracts are executable documentation. They should clearly communicate the intent and structure of your data.

**DO:** Use clear, domain-specific names for fields and contracts.

```elixir
# Good: Clear, semantic, and documents the business rule.
defcontract :user_registration do
  required :email_address, :string, format: ~r/@/
  required :password_hash, :string, min_length: 12
  required :agreed_to_terms_at, :utc_datetime
end
```

**DON'T:** Use abbreviated or generic names that hide meaning.

```elixir
# Bad: Ambiguous and unhelpful.
defcontract :data do
  required :f1, :string
  required :f2, :string
  required :f3, :datetime
end
```

### Compose, Don't Repeat

If you find yourself defining the same set of fields in multiple contracts, extract them into a shared, reusable contract and compose them.

**DO:** Create small, reusable contracts for common data structures like timestamps or pagination.

```elixir
defmodule MyApp.SharedContracts do
  use Perimeter.Contract

  defcontract :timestamps do
    required :inserted_at, :utc_datetime
    required :updated_at, :utc_datetime
  end

  defcontract :pagination_params do
    optional :page, :integer, min: 1, default: 1
    optional :per_page, :integer, min: 1, max: 100, default: 25
  end
end

defmodule MyApp.UserContracts do
  use Perimeter.Contract
  import MyApp.SharedContracts

  # Compose the shared contract
  defcontract :user_output do
    required :id, :string
    required :email, :string
    compose :timestamps
  end
end
```

**DON'T:** Copy and paste field definitions across multiple contracts. This leads to maintenance headaches when a shared field needs to be changed.

### Separate Validation from Business Logic

A contract's job is to validate the **shape and integrity** of data, not to perform business operations.

**DO:** Keep custom validators focused on pure data validation.

```elixir
# Good: The validator checks a pure data constraint.
defcontract :booking do
  required :start_date, :date
  required :end_date, :date

  validate :dates_are_sequential
end

defp dates_are_sequential(%{start_date: s, end_date: e}) do
  if Date.compare(e, s) == :gt, do: :ok, else: {:error, ...}
end
```

**DON'T:** Put complex business logic, database calls, or external API requests inside a custom validator. This makes your contracts slow, impure, and hard to test.

```elixir
# Bad: This validator is performing business logic.
defcontract :order do
  required :items, {:list, :map}
  validate :check_inventory_levels_in_db # Don't do this!
end

# The correct approach is to do this check in your business logic
# AFTER the contract has been validated.
@guard input: :order
def place_order(params) do
  # The contract has validated the shape of `params`.
  # Now, perform the business logic checks.
  with :ok <- check_inventory(params.items) do
    # ...
  end
end
```

## 2. Guard Best Practices

### Guard at the System Perimeter

The most effective place to use `@guard` is at the entry points of your application or context. This creates the "Defensive Perimeter."

**DO:** Place guards on:
*   Phoenix Controller actions.
*   The public API functions of your core contexts (e.g., `Accounts.create_user/1`).
*   GenServer `handle_call`/`handle_cast` functions, or the public API that calls them.
*   The entry point for background job processors.

### Trust the Interior

Once a function call has passed through a guard, **trust the data**. The whole point of the "Offensive Interior" is that you can write assertive, non-defensive code.

**DO:** Use assertive pattern matching and access inside a guarded function.

```elixir
@guard input: :user_with_profile
def process_user(user) do
  # We know `user` is valid. We can be assertive.
  # This is much clearer than `get_in` or defensive checks.
  %{email: email, profile: %{name: name}} = user

  Logger.info("Processing user #{name} with email #{email}")
end
```

**DON'T:** Re-validate data that has already been validated by a guard. This is redundant and defeats the purpose of the pattern.

```elixir
# Bad: Redundant, defensive check.
@guard input: :user_with_profile
def process_user(user) do
  # The guard already confirmed `profile` is a map. This is unnecessary.
  if is_map(user.profile) do
    # ...
  end
end
```

## 3. Common Anti-Patterns to Avoid

### Anti-Pattern: The Chain of Guards

Calling a guarded function from within another guarded function can be a sign of a design flaw. It often means you are performing validation too deep inside your system.

```elixir
# Anti-pattern: Chained guards
defmodule A do
  use Perimeter
  defcontract :a_contract, do: #...
  
  @guard input: :a_contract
  def process(params) do
    B.process(params) # B.process is also guarded
  end
end

defmodule B do
  use Perimeter
  defcontract :b_contract, do: #...

  @guard input: :b_contract
  def process(params) do
    #...
  end
end
```

**Solution:** Guard only the outermost function (`A.process/1`). Module `B` should assume it receives valid data and not have its own guard. Create a clear "public" interface for your context, and only guard that. Internal functions should trust their inputs.

### Anti-Pattern: The Overly-Complex Custom Validator

If your custom validator function is more than a few lines long and contains complex `case` or `cond` statements, it's a sign that you are mixing business logic with validation.

**Solution:** Break the logic out. Create a contract that validates the basic data types. Then, in a separate function (or the main body of the guarded function), perform the more complex business rule validation.

### Anti-Pattern: The Anemic Contract

A contract that only checks for the existence of keys without checking their types is not providing much safety.

```elixir
# Bad: This allows `%{user_id: "not-an-integer"}` to pass.
defcontract :anemic do
  required :user_id, :any
end
```

**Solution:** Be as specific as possible with types and constraints. The more specific your contract, the more safety you get.

```elixir
# Good: Provides strong guarantees about the data.
defcontract :robust do
  required :user_id, :integer, min: 1
end
```

### Anti-Pattern: Bypassing the Guard

It can be tempting to call an internal, unguarded version of a function to "skip" validation. This breaks the security model of the Defensive Perimeter.

```elixir
# Anti-pattern
defmodule MyContext do
  use Perimeter
  
  defcontract :create_params, do: #...

  @guard input: :create_params
  def create_user(params), do: do_create_user(params)

  # Other functions in the app start calling this directly
  # to bypass validation. This is dangerous!
  def do_create_user(params) do
    # ...
  end
end
```

**Solution:** Make the unguarded function private (`defp`). This forces all external callers to go through the public, guarded function, ensuring that the contract is always enforced at the perimeter.

---

### `guides/testing_guide.md`

# Testing with Perimeter

Testing is a critical part of a contract-driven workflow. `Perimeter` is designed to be highly testable and to make your application tests more robust.

## Table of Contents

1.  [Testing Your Contracts](#1-testing-your-contracts)
    *   Using `Perimeter.validate/2`
    *   A Simple Contract Test Helper
2.  [Testing Guarded Functions](#2-testing-guarded-functions)
    *   Testing the "Happy Path"
    *   Testing Validation Failures
3.  [Testing with Different Enforcement Levels](#3-testing-with-different-enforcement-levels)

## 1. Testing Your Contracts

Since contracts are central to your application's correctness, it's a good practice to write tests for the contracts themselves, especially complex ones with custom validators.

You can test a contract directly using `Perimeter.validate/2`.

### Using `Perimeter.validate/2`

The `Perimeter.validate/2` function allows you to invoke contract validation outside of a guard. It takes the module where the contract is defined and the contract name.

```elixir
defmodule MyApp.UserContractsTest do
  use ExUnit.Case
  alias MyApp.UserContracts

  describe "user_registration contract" do
    test "succeeds with valid data" do
      valid_data = %{
        email_address: "test@example.com",
        password_hash: "a-very-secure-hash-123",
        agreed_to_terms_at: DateTime.utc_now()
      }

      assert {:ok, _} = Perimeter.validate(UserContracts, :user_registration, valid_data)
    end

    test "fails when email is invalid" do
      invalid_data = %{
        email_address: "not-an-email",
        password_hash: "a-very-secure-hash-123",
        agreed_to_terms_at: DateTime.utc_now()
      }

      expected_error =
        {:error,
         %Perimeter.Error{
           violations: [
             %{field: :email_address, error: "has invalid format"}
           ]
         }}

      # Use pattern matching for a more robust assertion
      assert {:error, %Perimeter.Error{violations: [%{field: :email_address}]}} =
               Perimeter.validate(UserContracts, :user_registration, invalid_data)
    end
  end
end
```

### A Simple Contract Test Helper

You can create simple test helpers to make your contract tests more concise.

```elixir
# test/support/contract_case.ex
defmodule MyApp.ContractCase do
  use ExUnit.CaseTemplate

  using do
    quote do
      import MyApp.ContractCase
    end
  end

  def assert_contract_ok(module, contract, data) do
    case Perimeter.validate(module, contract, data) do
      {:ok, _} -> :ok
      {:error, error} -> flunk("Expected contract to be valid, but got error: #{inspect(error)}")
    end
  end

  def assert_contract_error(module, contract, data, expected_field) do
    case Perimeter.validate(module, contract, data) do
      {:error, %Perimeter.Error{violations: violations}} ->
        assert Enum.any?(violations, &(&1.field == unquote(expected_field))),
               "Expected an error for field `#{unquote(expected_field)}` but didn't find one."
      {:ok, _} ->
        flunk("Expected contract to be invalid, but it was valid.")
    end
  end
end

# In your test:
defmodule MyApp.UserContractsTest do
  use MyApp.ContractCase # Use your custom case template

  alias MyApp.UserContracts

  test "succeeds with valid data" do
    valid_data = %{email_address: "test@example.com", ...}
    assert_contract_ok(UserContracts, :user_registration, valid_data)
  end

  test "fails with bad email" do
    invalid_data = %{email_address: "bad", ...}
    assert_contract_error(UserContracts, :user_registration, invalid_data, :email_address)
  end
end
```

## 2. Testing Guarded Functions

When testing a module that uses `@guard`, you are typically testing two things: how it behaves with valid data, and how it behaves with invalid data.

### Testing the "Happy Path"

This is your standard test case. You provide valid data and assert that the function returns the expected success value. The guard is implicitly tested because the function executes as expected.

```elixir
defmodule MyApp.Actions.CreateUserTest do
  use ExUnit.Case
  alias MyApp.Actions.CreateUser

  test "creates a user with valid params" do
    valid_params = %{email: "test@example.com"}

    # The guard will validate `valid_params` and allow the function to run.
    assert {:ok, %{user: %User{email: "test@example.com"}}} =
             CreateUser.run(valid_params, %{})
  end
end
```

### Testing Validation Failures

To test the guard's failure case, provide invalid data and assert that the function returns a `Perimeter.Error`. Because your `test` environment is configured for `:strict` enforcement, the guard will immediately return an error without executing the function body.

```elixir
test "returns a validation error for invalid params" do
  invalid_params = %{email: "not-valid"} # Missing the @ symbol

  # The guard will reject the params and return a Perimeter.Error
  assert {:error, %Perimeter.Error{violations: violations}} =
           CreateUser.run(invalid_params, %{})

  # You can make your assertion more specific
  assert Enum.any?(violations, &(&1.field == :email))
end
```

This is a powerful way to test your perimeters. You don't need to mock anything; you are directly testing the contract enforcement that will happen in production.

## 3. Testing with Different Enforcement Levels

Sometimes you may want to test the behavior of a function when a guard is set to a non-strict level like `:warn`. You can use `Application.put_env/3` to temporarily change the enforcement level for a specific test.

**Note:** This is an advanced use case. Most of the time, you should test with `:strict` enforcement.

```elixir
test "logs a warning but still executes when enforcement is :warn" do
  # Temporarily set the enforcement level for this test only
  Application.put_env(:perimeter, :enforcement_level, :warn, persistent: true)

  invalid_params = %{email: "not-valid"}

  # Use ExUnit.CaptureLog to assert that a warning was logged.
  assert_logged "[warn] Perimeter contract violation" ->
    # The function body will still execute and likely raise an error
    # or return a different error tuple because the data is bad.
    # The exact result depends on the function's implementation.
    assert {:error, :some_internal_error} = CreateUser.run(invalid_params, %{})
  end

  # It's good practice to restore the original config after the test,
  # though ExUnit's sandboxing often handles this.
  Application.put_env(:perimeter, :enforcement_level, :strict, persistent: true)
end
```
</file>

<file path="PERIMETER_gem_0004.md">
Excellent. The library documentation is shaping up nicely. The final core document needed is an **API Reference**. This is crucial for users who know what they want to do and just need to look up the specifics of a function or macro.

This document will be generated by `ex_doc` but we'll structure the modules and their `@moduledoc` and `@doc` attributes to produce a clear and comprehensive reference. I'll outline the key modules and their documentation here.

This would live in the `lib/` directory and be the source for the final HexDocs page.

---

### `lib/perimeter/contract.ex` (Final API-focused version)

```elixir
defmodule Perimeter.Contract do
  @moduledoc """
  A DSL for defining declarative data contracts.

  Contracts are the core of `Perimeter`. They provide a single source of truth
  for the expected shape, types, and constraints of your data. These contracts
  are defined at compile time and are used by `Perimeter.Guard` to validate
  data at runtime.

  ## Key Concepts

  - **Declarative:** You describe *what* valid data looks like, not *how* to validate it.
  - **Composable:** Simple contracts can be composed into more complex ones.
  - **Executable Documentation:** Contracts serve as a reliable, always-up-to-date
    reference for your data structures.

  This module's macros are typically made available via `use Perimeter`.
  """

  @doc """
  Defines a contract.

  A contract is a named set of rules that are evaluated within the `do` block.

  ### Example

      defcontract :create_user_params do
        required :email, :string, format: ~r/@/
        optional :name, :string, max_length: 100
      end
  """
  defmacro defcontract(name, do: block)

  @typedoc """
  The type of a field in a contract. Can be a basic type, a nested type, or `:any`.
  """
  @type field_type ::
          :string
          | :integer
          | :float
          | :boolean
          | :atom
          | :map
          | :list
          | :utc_datetime
          | :date
          | :time
          | {:list, field_type()}
          | {:map, keyword()}
          | :any

  @doc """
  Defines a required field within a contract.

  The function will return an error if this field is missing (`nil` is considered missing).

  ### Options

  - `in`: A list of allowed values.
  - `min_length`: Minimum length for a string.
  - `max_length`: Maximum length for a string.
  - `format`: A regular expression that the string must match.
  - `min`: The minimum allowed value for an integer or float.
  - `max`: The maximum allowed value for an integer or float.
  - `min_items`: The minimum number of items in a list.
  - `max_items`: The maximum number of items in a list.

  ### Examples

      required :status, :atom, in: [:active, :archived]
      required :name, :string, min_length: 2
      required :age, :integer, min: 18
  """
  defmacro required(field, type, opts \\ [])

  @doc """
  Defines an optional field within a contract.

  The validation will pass if the field is missing. If the field is present,
  it must conform to the given type and options.

  ### Options

  Accepts all the same options as `required/3`, plus:

  - `default`: A value to be injected into the data if the key is missing.
    The guard will pass this enriched data to your function.

  ### Examples

      optional :role, :string, default: "user"
      optional :nickname, :string
  """
  defmacro optional(field, type, opts \\ [])

  @doc """
  Registers a custom validation function to be run after all field validations.

  The function must be defined in the same module and should accept one argument
  (the map of validated data). It must return `:ok` on success or
  `{:error, %{field: atom(), error: String.t()}}` on failure.

  ### Example

      defcontract :event do
        required :start_at, :utc_datetime
        required :end_at, :utc_datetime
        validate :end_at_must_be_after_start_at
      end

      defp end_at_must_be_after_start_at(params) do
        # ... logic ...
      end
  """
  defmacro validate(function_name)

  @doc """
  Composes one or more existing contracts into the current one.

  This is a powerful tool for building reusable contracts and avoiding repetition.
  The macro accepts a single contract name or a list of names.

  ### Example

      defmodule Shared do
        use Perimeter.Contract
        defcontract :timestamps, do: # ...
      end

      defmodule User do
        use Perimeter.Contract
        import Shared

        defcontract :user_output do
          required :id, :string
          compose :timestamps  # All fields from :timestamps are included here
        end
      end
  """
  defmacro compose(contract_name_or_names)
end
```
---
### `lib/perimeter/guard.ex` (Final API-focused version)

```elixir
defmodule Perimeter.Guard do
  @moduledoc """
  Provides the `@guard` macro to enforce contracts at function perimeters.

  The guard is the mechanism that creates the "Defensive Perimeter." It wraps
  a function definition, creating a layer of protection that validates incoming
s  data before your function's code is ever executed.

  This module's macros are typically made available via `use Perimeter`.
  """

  @doc """
  Guards a function with an input and/or output contract.

  This macro must be placed directly above a function definition (`def` or `defp`).
  It analyzes the function below it and wraps it in validation logic.

  ### Options

  - `:input` (required): The atom name of the contract to validate the function's
    first argument against.
  - `:output` (optional): The atom name of the contract to validate the function's
    success return value (`{:ok, value}`). The `value` is what gets validated.
    Error tuples (`{:error, _}`) are passed through without validation.
  - `:enforcement` (optional): Overrides the global enforcement level for this specific
    guard. Can be `:strict`, `:warn`, or `:log`.

  ### How it Works

  At compile time, `@guard` transforms your function definition.
  For example, this:

      @guard input: :my_contract
      def my_function(params) do
        # ... your code ...
      end

  Is conceptually transformed into this:

      def my_function(params) do
        case Perimeter.validate(MyModule, :my_contract, params) do
          {:ok, validated_params} ->
            # Call the original function body
            __original_my_function__(validated_params)
          {:error, error} ->
            # Handle violation based on enforcement level
            Perimeter.ViolationHandler.handle(error, :strict)
        end
      end
  """
  defmacro guard(opts)
end
```

---
### `lib/perimeter/validator.ex` (A new module for the public API)

```elixir
defmodule Perimeter.Validator do
  @moduledoc """
  Provides a public API for programmatic contract validation.

  While `@guard` is the most common way to use Perimeter, you may sometimes
  need to manually trigger validation. This module provides a stable, public
  interface for doing so.
  """

  @doc """
  Validates data against a contract.

  This is the primary function for manual validation. It returns a standard
  `{:ok, transformed_data}` or `{:error, %Perimeter.Error{}}` tuple.

  ### Parameters
    - `module`: The module where the contract is defined.
    - `contract_name`: The atom name of the contract.
    - `data`: The map of data to validate.

  ### Returns
    - `{:ok, data}`: If validation is successful. The returned `data` may be
      enriched with default values defined in the contract.
    - `{:error, %Perimeter.Error{}}`: If validation fails.

  ### Example

      data = %{email: "test@example.com"}
      case Perimeter.Validator.validate(MyApp.UserContracts, :create_user, data) do
        {:ok, validated_data} ->
          # Continue processing
          Accounts.create_user(validated_data)
        {:error, error} ->
          # Handle the validation error
          Logger.error("Invalid user data: #{inspect(error)}")
      end
  """
  @spec validate(module :: module(), contract_name :: atom(), data :: map()) ::
          {:ok, map()} | {:error, Perimeter.Error.t()}
  def validate(module, contract_name, data) do
    # ... implementation delegates to internal validation logic ...
  end

  @doc """
  Validates data, raising an exception on failure.

  This is a convenience function useful in contexts where you expect data to
  be valid, such as in tests or after data has already been sanitized.

  ### Returns
    - `data`: The validated (and possibly transformed) data map if successful.

  ### Raises
    - `Perimeter.ValidationError`: If the validation fails. The exception struct
      contains the underlying `Perimeter.Error` struct.

  ### Example

      # In a test, where you expect validation to pass
      valid_data = %{email: "test@example.com"}
      validated_data = Perimeter.Validator.validate!(MyApp.UserContracts, :create_user, valid_data)
      assert validated_data.email == "test@example.com"
  """
  @spec validate!(module :: module(), contract_name :: atom(), data :: map()) :: map()
  def validate!(module, contract_name, data) do
    case validate(module, contract_name, data) do
      {:ok, validated_data} -> validated_data
      {:error, error} -> raise Perimeter.ValidationError, error: error
    end
  end
end

# Define the custom exception
defmodule Perimeter.ValidationError do
  defexception [:message, :error]

  @impl true
  def exception(opts) do
    error = Keyword.fetch!(opts, :error)
    message = "Perimeter contract validation failed. #{error.message}"
    %__MODULE__{message: message, error: error}
  end
end
```

---
This set of documented modules provides a solid foundation for the library's HexDocs. It clearly separates the concerns:

*   `Perimeter.Contract`: For users **defining** data shapes.
*   `Perimeter.Guard`: For users **enforcing** those shapes.
*   `Perimeter.Validator`: For users who need to **manually trigger** validation.
*   `Perimeter.Error`: For users who need to **handle failures**.

The documentation is rich with examples and clearly explains the "how" and "why," directly tying back to the core philosophy you established. This completes the core set of documentation needed for a successful v0.1.0 release.
</file>

<file path="PERIMETER_gem_0005.md">
Excellent. The library documentation is shaping up nicely. The final core document needed is an **API Reference**. This is crucial for users who know what they want to do and just need to look up the specifics of a function or macro.

This document will be generated by `ex_doc` but we'll structure the modules and their `@moduledoc` and `@doc` attributes to produce a clear and comprehensive reference. I'll outline the key modules and their documentation here.

This would live in the `lib/` directory and be the source for the final HexDocs page.

---

### `lib/perimeter/contract.ex` (Final API-focused version)

```elixir
defmodule Perimeter.Contract do
  @moduledoc """
  A DSL for defining declarative data contracts.

  Contracts are the core of `Perimeter`. They provide a single source of truth
  for the expected shape, types, and constraints of your data. These contracts
  are defined at compile time and are used by `Perimeter.Guard` to validate
  data at runtime.

  ## Key Concepts

  - **Declarative:** You describe *what* valid data looks like, not *how* to validate it.
  - **Composable:** Simple contracts can be composed into more complex ones.
  - **Executable Documentation:** Contracts serve as a reliable, always-up-to-date
    reference for your data structures.

  This module's macros are typically made available via `use Perimeter`.
  """

  @doc """
  Defines a contract.

  A contract is a named set of rules that are evaluated within the `do` block.

  ### Example

      defcontract :create_user_params do
        required :email, :string, format: ~r/@/
        optional :name, :string, max_length: 100
      end
  """
  defmacro defcontract(name, do: block)

  @typedoc """
  The type of a field in a contract. Can be a basic type, a nested type, or `:any`.
  """
  @type field_type ::
          :string
          | :integer
          | :float
          | :boolean
          | :atom
          | :map
          | :list
          | :utc_datetime
          | :date
          | :time
          | {:list, field_type()}
          | {:map, keyword()}
          | :any

  @doc """
  Defines a required field within a contract.

  The function will return an error if this field is missing (`nil` is considered missing).

  ### Options

  - `in`: A list of allowed values.
  - `min_length`: Minimum length for a string.
  - `max_length`: Maximum length for a string.
  - `format`: A regular expression that the string must match.
  - `min`: The minimum allowed value for an integer or float.
  - `max`: The maximum allowed value for an integer or float.
  - `min_items`: The minimum number of items in a list.
  - `max_items`: The maximum number of items in a list.

  ### Examples

      required :status, :atom, in: [:active, :archived]
      required :name, :string, min_length: 2
      required :age, :integer, min: 18
  """
  defmacro required(field, type, opts \\ [])

  @doc """
  Defines an optional field within a contract.

  The validation will pass if the field is missing. If the field is present,
  it must conform to the given type and options.

  ### Options

  Accepts all the same options as `required/3`, plus:

  - `default`: A value to be injected into the data if the key is missing.
    The guard will pass this enriched data to your function.

  ### Examples

      optional :role, :string, default: "user"
      optional :nickname, :string
  """
  defmacro optional(field, type, opts \\ [])

  @doc """
  Registers a custom validation function to be run after all field validations.

  The function must be defined in the same module and should accept one argument
  (the map of validated data). It must return `:ok` on success or
  `{:error, %{field: atom(), error: String.t()}}` on failure.

  ### Example

      defcontract :event do
        required :start_at, :utc_datetime
        required :end_at, :utc_datetime
        validate :end_at_must_be_after_start_at
      end

      defp end_at_must_be_after_start_at(params) do
        # ... logic ...
      end
  """
  defmacro validate(function_name)

  @doc """
  Composes one or more existing contracts into the current one.

  This is a powerful tool for building reusable contracts and avoiding repetition.
  The macro accepts a single contract name or a list of names.

  ### Example

      defmodule Shared do
        use Perimeter.Contract
        defcontract :timestamps, do: # ...
      end

      defmodule User do
        use Perimeter.Contract
        import Shared

        defcontract :user_output do
          required :id, :string
          compose :timestamps  # All fields from :timestamps are included here
        end
      end
  """
  defmacro compose(contract_name_or_names)
end
```
---
### `lib/perimeter/guard.ex` (Final API-focused version)

```elixir
defmodule Perimeter.Guard do
  @moduledoc """
  Provides the `@guard` macro to enforce contracts at function perimeters.

  The guard is the mechanism that creates the "Defensive Perimeter." It wraps
  a function definition, creating a layer of protection that validates incoming
s  data before your function's code is ever executed.

  This module's macros are typically made available via `use Perimeter`.
  """

  @doc """
  Guards a function with an input and/or output contract.

  This macro must be placed directly above a function definition (`def` or `defp`).
  It analyzes the function below it and wraps it in validation logic.

  ### Options

  - `:input` (required): The atom name of the contract to validate the function's
    first argument against.
  - `:output` (optional): The atom name of the contract to validate the function's
    success return value (`{:ok, value}`). The `value` is what gets validated.
    Error tuples (`{:error, _}`) are passed through without validation.
  - `:enforcement` (optional): Overrides the global enforcement level for this specific
    guard. Can be `:strict`, `:warn`, or `:log`.

  ### How it Works

  At compile time, `@guard` transforms your function definition.
  For example, this:

      @guard input: :my_contract
      def my_function(params) do
        # ... your code ...
      end

  Is conceptually transformed into this:

      def my_function(params) do
        case Perimeter.validate(MyModule, :my_contract, params) do
          {:ok, validated_params} ->
            # Call the original function body
            __original_my_function__(validated_params)
          {:error, error} ->
            # Handle violation based on enforcement level
            Perimeter.ViolationHandler.handle(error, :strict)
        end
      end
  """
  defmacro guard(opts)
end
```

---
### `lib/perimeter/validator.ex` (A new module for the public API)

```elixir
defmodule Perimeter.Validator do
  @moduledoc """
  Provides a public API for programmatic contract validation.

  While `@guard` is the most common way to use Perimeter, you may sometimes
  need to manually trigger validation. This module provides a stable, public
  interface for doing so.
  """

  @doc """
  Validates data against a contract.

  This is the primary function for manual validation. It returns a standard
  `{:ok, transformed_data}` or `{:error, %Perimeter.Error{}}` tuple.

  ### Parameters
    - `module`: The module where the contract is defined.
    - `contract_name`: The atom name of the contract.
    - `data`: The map of data to validate.

  ### Returns
    - `{:ok, data}`: If validation is successful. The returned `data` may be
      enriched with default values defined in the contract.
    - `{:error, %Perimeter.Error{}}`: If validation fails.

  ### Example

      data = %{email: "test@example.com"}
      case Perimeter.Validator.validate(MyApp.UserContracts, :create_user, data) do
        {:ok, validated_data} ->
          # Continue processing
          Accounts.create_user(validated_data)
        {:error, error} ->
          # Handle the validation error
          Logger.error("Invalid user data: #{inspect(error)}")
      end
  """
  @spec validate(module :: module(), contract_name :: atom(), data :: map()) ::
          {:ok, map()} | {:error, Perimeter.Error.t()}
  def validate(module, contract_name, data) do
    # ... implementation delegates to internal validation logic ...
  end

  @doc """
  Validates data, raising an exception on failure.

  This is a convenience function useful in contexts where you expect data to
  be valid, such as in tests or after data has already been sanitized.

  ### Returns
    - `data`: The validated (and possibly transformed) data map if successful.

  ### Raises
    - `Perimeter.ValidationError`: If the validation fails. The exception struct
      contains the underlying `Perimeter.Error` struct.

  ### Example

      # In a test, where you expect validation to pass
      valid_data = %{email: "test@example.com"}
      validated_data = Perimeter.Validator.validate!(MyApp.UserContracts, :create_user, valid_data)
      assert validated_data.email == "test@example.com"
  """
  @spec validate!(module :: module(), contract_name :: atom(), data :: map()) :: map()
  def validate!(module, contract_name, data) do
    case validate(module, contract_name, data) do
      {:ok, validated_data} -> validated_data
      {:error, error} -> raise Perimeter.ValidationError, error: error
    end
  end
end

# Define the custom exception
defmodule Perimeter.ValidationError do
  defexception [:message, :error]

  @impl true
  def exception(opts) do
    error = Keyword.fetch!(opts, :error)
    message = "Perimeter contract validation failed. #{error.message}"
    %__MODULE__{message: message, error: error}
  end
end
```

---
This set of documented modules provides a solid foundation for the library's HexDocs. It clearly separates the concerns:

*   `Perimeter.Contract`: For users **defining** data shapes.
*   `Perimeter.Guard`: For users **enforcing** those shapes.
*   `Perimeter.Validator`: For users who need to **manually trigger** validation.
*   `Perimeter.Error`: For users who need to **handle failures**.

The documentation is rich with examples and clearly explains the "how" and "why," directly tying back to the core philosophy you established. This completes the core set of documentation needed for a successful v0.1.0 release.
</file>

<file path="PERIMETER_gem_0006.md">
Excellent. With the core library documentation complete, the final piece is to create the top-level **Project Documentation**. This includes files that are crucial for community adoption, contribution, and long-term maintenance of the `Perimeter` library.

These documents will live in the root of the project repository.

---

### `.github/CONTRIBUTING.md`

# Contributing to Perimeter

Thank you for your interest in contributing to Perimeter! We welcome contributions of all kinds, from bug reports and documentation improvements to new features.

## Guiding Philosophy

Perimeter is built on the **"Defensive Perimeter / Offensive Interior"** pattern. All contributions should align with this core philosophy:

1.  **Perimeters are for Safety:** The library's features should focus on making it easier and more effective to validate data at the edges of a system.
2.  **The Interior is for Freedom:** We intentionally avoid adding features that would constrain or inspect code *inside* a guarded function.
3.  **Clarity and Explicitness:** Contracts and guards should be easy to read and understand. The DSL should be declarative and expressive.
4.  **Performance Matters:** Because this is a runtime library, performance is a key consideration. Changes should be benchmarked where appropriate.

Before starting work on a major feature, please [open an issue](https://github.com/your-org/perimeter/issues) to discuss your idea.

## Getting Started

1.  Fork the repository on GitHub.
2.  Clone your fork locally: `git clone git@github.com:your-username/perimeter.git`
3.  Install dependencies: `mix deps.get`
4.  Run the test suite to ensure everything is working: `mix test`

## Making Changes

1.  Create a new branch for your changes: `git checkout -b feature/my-new-feature` or `fix/a-nasty-bug`.
2.  Write your code. Please include tests for any new functionality.
3.  Ensure all existing tests continue to pass: `mix test`.
4.  Check code style and quality: `mix credo --strict` and `mix format`.
5.  Add or update documentation. All public functions should have `@doc` and `@spec` annotations. If you add a major feature, please update the guides in the `guides/` directory.
6.  Add an entry to the `CHANGELOG.md` file under the "Unreleased" section.

## Submitting a Pull Request

1.  Push your branch to your fork on GitHub.
2.  [Open a pull request](https://github.com/your-org/perimeter/pulls) against the `main` branch.
3.  In the PR description, provide a clear explanation of the problem you are solving and the changes you have made. Link to any relevant issues.
4.  The maintainers will review your PR. We may ask for changes or clarifications.

## Code of Conduct

All contributors are expected to follow our [Code of Conduct](./CODE_OF_CONDUCT.md). Please be respectful and constructive in all communications.

---

### `CHANGELOG.md`

# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/), and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added
- Your new feature.

### Changed
- An existing feature that was updated.

### Fixed
- A bug that was squashed.

## [0.1.0] - YYYY-MM-DD

### Added
- Initial release of the `Perimeter` library.
- `Perimeter.Contract` module with `defcontract/2`, `required/3`, `optional/3`, `validate/1`, and `compose/1` macros for defining data contracts.
- `Perimeter.Guard` module with the `@guard/1` macro for enforcing contracts on function perimeters.
- `Perimeter.Validator` module with a public API (`validate/3` and `validate!/3`) for manual validation.
- `Perimeter.Error` and `Perimeter.ValidationError` structs for structured error handling.
- Configuration system for setting enforcement levels (`:strict`, `:warn`, `:log`) via `config.exs`.
- Core documentation, including a README, usage guide, best practices guide, and testing guide.

---

### `ROADMAP.md`

# Perimeter Development Roadmap

This document outlines the planned future direction for the `Perimeter` library. This is a living document and may change based on community feedback and evolving needs.

## Post-1.0: "Clarity and Integration"

The focus after the initial stable release will be on improving the developer experience and integrating with the broader Elixir ecosystem.

### Q1: Enhanced Tooling
- **Credo Checks:**
  - A check to identify public functions that are missing a `@guard`.
  - A check to warn against the "Chain of Guards" anti-pattern.
- **Test Helpers:**
  - A more formal `Perimeter.ContractCase` test helper built into the library.
  - Property-based testing helpers for generating valid and invalid data from contracts.

### Q2: Ecto Integration
- **`Ecto.Changeset` Integration:**
  - A function to convert a `Perimeter.Error` struct into an `Ecto.Changeset` for easy use in forms and APIs.
  - `defcontract from_changeset: MyApp.User.changeset/2` to automatically derive a contract from an Ecto changeset function.

### Q3: Phoenix Integration
- **`Perimeter.Plug`:**
  - A plug that automatically catches `Perimeter.ValidationError` and `Perimeter.Error` tuples, returning a standardized `422 Unprocessable Entity` response. This would simplify `FallbackController` implementations.
- **LiveView Integration:**
  - Best practice guides and potentially helpers for using Perimeter to validate LiveView events and form submissions.

## Future: "Performance and Intelligence"

Longer-term goals focus on optimizing performance and making the library smarter.

- **JIT-Compiled Validators:**
  - Investigate using a library like `nimble_parsec` or `ex_jason`-style runtime compilation to create extremely fast, specialized validation functions from contracts.
- **Telemetry and Observability:**
  - Add more detailed `:telemetry` events for validation timing, failure modes, and cache performance.
  - Provide a default `LiveDashboard` page for monitoring contract health.
- **Type-Hinting and Static Analysis:**
  - A Mix task to generate `@spec`s from contracts, providing better integration with Dialyzer and developer tooling for code inside the "Offensive Interior".

## How to Contribute

If you are interested in working on any of these features, please see our [Contributing Guide](./.github/CONTRIBUTING.md) and open an issue to start a discussion!

---
This concludes the creation of a comprehensive, professional-grade open-source library project. You have:

1.  A clear, well-documented **core library**.
2.  A set of **guides** explaining the philosophy, usage, and best practices.
3.  A formal **API reference** via `ex_doc`.
4.  Community-facing **project documents** (`CONTRIBUTING.md`, `CHANGELOG.md`, `ROADMAP.md`).

This entire package is a direct and brilliant evolution of the initial problem analysis. It solves the original challenge not with a simple patch, but with a robust, reusable, and well-thought-out new paradigm.
</file>

<file path="PERIMETER_gem_0010.md">
Of course. This is a fantastic directive. José Valim's talk provides a deep, philosophical foundation for Elixir development. Rebuilding the plan for `Perimeter` with this wisdom will elevate it from a useful utility to a truly idiomatic and powerful library that teaches Elixir best practices by its very design.

The core innovation of "Defensive Perimeter / Offensive Interior" remains, but we will reframe it and the library's entire structure through the lens of Valim's key principles.

Here is the complete, ground-up plan for the `Perimeter` library, redesigned with this new foundation.

---

## Part 1: The New Philosophy (The "Why")

First, we will create a foundational document that explicitly states the library's philosophy, directly referencing the wisdom from the talk. This will guide all other development and documentation.

### `guides/philosophy_and_principles.md`

# The Perimeter Philosophy: A Pattern Language for Elixir

`Perimeter` is more than a validation library; it is an implementation of a design pattern for building robust, maintainable Elixir systems. Its design is guided by a set of core principles derived from Elixir's functional nature and the wisdom of its community.

### Principle 1: Design Patterns are About Problems, Not Solutions

As José Valim emphasized, a design pattern describes a recurring *problem* and the *core of its solution*, which can be implemented in many ways. `Perimeter` addresses the following recurring problems:

1.  **The Perimeter Problem:** How do we ensure data integrity at the edge of a system (e.g., APIs, GenServers, context perimeters) without littering our core logic with defensive checks?
2.  **The Explicitness Problem:** How do we make the data requirements of our functions and modules explicit and self-documenting, especially when working with plain maps?
3.  **The Confidence Problem:** How can we write assertive, "let it crash" style code in our function bodies with confidence that the input data won't cause trivial crashes due to incorrect shape or type?

`Perimeter` provides an idiomatic Elixir solution to these problems through **explicit, runtime-enforced contracts at system perimeters.**

### Principle 2: Decouple Behavior, State, and Mutability

Elixir's power comes from its decoupling of three core concepts that are often bundled in object-oriented languages:

*   **Behavior:** Logic, implemented in **Modules**.
*   **State:** Data, represented by **Structs and Maps**.
*   **Mutability:** The illusion of change over time, managed by **Processes**.

`Perimeter` is designed to work within this decoupled world.
*   It validates **State** (data) as it passes into **Behavior** (modules).
*   It ensures the messages passed to **Processes** (mutability) are well-formed.

### Principle 3: The Rule of Least Expressiveness

When solving a problem, we should use the least expressive (simplest) model that results in a natural program. `Perimeter` is a powerful tool, but it is not always the first tool you should reach for.

Follow this hierarchy when deciding how to implement logic:

1.  **Simple Function & Pattern Matching:** The simplest solution. If you have a small, fixed set of known inputs, use multi-clause functions. This is the least expressive and often the best choice.
2.  **Higher-Order Functions:** If you need to customize behavior, passing an anonymous function as an argument is a simple and powerful strategy.
3.  **Behaviours:** When you need to define a contract with multiple, related functions (polymorphism over **behavior**), use a `behaviour`.
4.  **`Perimeter` Contracts:** When you need to enforce a contract on the **shape and content of data** (a map or struct), especially at a system perimeter, use `Perimeter`. It is more expressive than a simple function but more focused than a `protocol`.
5.  **Protocols:** When you need polymorphism that dispatches on the built-in **data type** (e.g., making something work for `list`, `map`, and `integer`), use a `protocol`.
6.  **Processes:** When your problem is inherently **stateful and concurrent**, model it with a process.

`Perimeter`'s sweet spot is at **level 4**. It provides a formal, reusable way to define and enforce contracts on data structures, which is a problem that frequently occurs at the perimeters of large systems.

---

## Part 2: The Redesigned Library (The "What")

With a new philosophy, the library's public API will be refined to be clearer and more powerful. We will introduce a new concept: the `Perimeter.Interface`.

### `README.md` (Revised)

# Perimeter

**An implementation of the "Defensive Perimeter" design pattern for Elixir.**

Perimeter helps you build robust applications by enforcing explicit data contracts at your system's perimeters, allowing you to write simple, assertive code in your core logic.

It is designed according to the principles of idiomatic Elixir: **favoring composition, decoupling behavior and state, and using the least expressive tool for the job.**

## The Problem: Complexity at the Perimeter

In any large system, modules need to exchange data. This often leads to defensive coding:
```elixir
def create_user(params) do
  # Is email a string? Does it exist? What about name?
  case get_in(params, ["user", "email"]) do
    nil -> {:error, :email_required}
    email when is_binary(email) ->
      # ... more checks ...
      # Finally, our core logic
    _ -> {:error, :invalid_email_type}
  end
end
```
This code is defensive, hard to read, and mixes validation with business logic.

## The Solution: The Defensive Perimeter Pattern

Perimeter allows you to solve this problem elegantly:

1.  **Define a Contract:** Describe the shape of your data.
2.  **Guard the Perimeter:** Enforce the contract on your public function.
3.  **Write Assertive Code:** Trust the data inside your function.

```elixir
defmodule MyApp.Accounts do
  use Perimeter # Imports Perimeter.Contract and Perimeter.Guard

  # 1. Define the contract
  defcontract :create_user_params do
    required :email, :string, format: ~r/@/
    optional :name, :string
  end

  # 2. Guard the perimeter function
  @guard input: :create_user_params
  def create_user(params) do
    # 3. Write simple, assertive code in the "Offensive Interior"
    # We know `params` has a valid email and an optional name.
    %User{}
    |> User.changeset(params)
    |> Repo.insert()
  end
end
```
The result is code that is cleaner, safer, and easier to reason about.

For a deeper dive, please read our **[Philosophy and Principles](guides/philosophy_and_principles.md)**.

### `lib/perimeter/interface.ex` (NEW)

```elixir
defmodule Perimeter.Interface do
  @moduledoc """
  A powerful composition of a `behaviour` and a `contract`.

  This macro allows you to define a single, unified interface that specifies
  both a set of required functions (like a `behaviour`) and the shape of the
  data they operate on (like a `contract`).

  This is Elixir's "composition over inheritance" philosophy in action. It directly
  facilitates the **Strategy** design pattern by defining a complete, enforceable
  contract for a pluggable module.

  ## Example

  Let's define a "ShippingCalculator" interface. Any module that implements
  this interface *must* provide a `calculate/2` function and define a contract
  for its `:opts` argument.

  ```elixir
  # In your library
  defmodule MyApp.ShippingCalculator do
    use Perimeter.Interface

    @callback calculate(order :: map(), opts :: map()) :: {:ok, integer()}

    defcontract :opts do
      # All implementations must define their own specific options.
      # This serves as a template.
    end
  end

  # A specific implementation
  defmodule MyApp.Calculators.FedEx do
    @behaviour MyApp.ShippingCalculator # Implements the behaviour
    use Perimeter.Contract             # To define the contract

    # Define the specific options contract for this implementation
    defcontract :opts do
      required :service_level, :atom, in: [:ground, :overnight]
      required :account_number, :string
    end

    # The guard here enforces the implementation-specific contract
    @impl true
    @guard input: :opts
    def calculate(_order, opts) do
      # Core logic knows `opts` are valid for FedEx
      # ...
      {:ok, 1500} # $15.00
    end
  end
  ```
  """
  defmacro __using__(_opts) do
    quote do
      import Perimeter.Contract
      import Kernel, except: [defcontract: 2]
      @behaviour __MODULE__
    end
  end
end
```

## Part 3: The New Guides (The "How")

The guides will be rewritten to teach the philosophy.

### `guides/usage_guide.md` (Revised)

This guide will now be structured according to the **Rule of Least Expressiveness**.

1.  **Introduction: Choosing the Right Tool**
    *   Briefly explains the hierarchy: simple functions -> higher-order functions -> `Perimeter`.
2.  **When to Use `Perimeter`**
    *   At Application Perimeters (Phoenix, Absinthe).
    *   At Context Perimeters.
    *   For defining complex, state-less strategies (e.g., calculation engines, formatters).
3.  **Core Workflow: Guarding a Context**
    *   A step-by-step example of guarding `Accounts.create_user/1`.
4.  **Advanced Workflow: Using `Perimeter.Interface` for the Strategy Pattern**
    *   A full example of building a pluggable system (like a `Notifier` with `EmailNotifier` and `SlackNotifier` implementations) using `Perimeter.Interface`.

### `guides/design_patterns.md` (NEW)

This new, critical document connects `Perimeter` directly to the patterns from Valim's talk.

# Perimeter and Elixir Design Patterns

`Perimeter` is not just a tool; it's a way to implement many classic and Elixir-specific design patterns cleanly and idiomatically.

### Facade Pattern

The `Perimeter.Guard` is a direct implementation of the Facade pattern. It provides a simple, single entry point (`my_function/1`) that hides the complex subsystem of data validation and normalization.

```elixir
# The @guard IS the facade. It simplifies the "validation subsystem."
@guard input: :complex_params
def handle_request(params) do
  # ... simple core logic ...
end
```

### Mediator Pattern

A `GenServer` or `LiveView` often acts as a Mediator. `Perimeter` strengthens the Mediator by validating the events and messages it receives, ensuring the Mediator doesn't crash due to malformed input from one of the many components it's mediating.

```elixir
defmodule MyLiveView do
  use Phoenix.LiveView
  use Perimeter

  defcontract :add_item_event do
    required :product_id, :string
  end

  # Guard the event handler (the Mediator's input)
  @guard input: :add_item_event
  def handle_event("add_item", params, socket) do
    # ... logic ...
  end
end
```

### Strategy Pattern

The new `Perimeter.Interface` is the ultimate tool for implementing the Strategy pattern in Elixir. It allows you to define a contract for both the *behavior* (the functions) and the *state* (the options/data) of a strategy.

See the `guides/usage_guide.md` for a full example.

### Interpreter Pattern

The Interpreter pattern involves parsing an input into a data structure (an Abstract Syntax Tree, or AST) and then "interpreting" that structure.

*   `Perimeter` shines in this pattern by **validating the AST**. Before your recursive `interpret/1` function runs, you can use a guard to ensure the entire tree of data is well-formed, preventing crashes deep in the recursion.

```elixir
defcontract :expression_ast do
  # Define the valid shapes for your language's nodes
  one_of [
    %{type: :literal, value: :integer},
    %{type: :add, left: :expression_ast, right: :expression_ast}
  ]
end

@guard input: :expression_ast
def interpret(ast) do
  # ... recursive interpretation logic ...
end
```

### Observer Pattern (Pub/Sub)

In a Pub/Sub system, publishers broadcast events that subscribers listen for. A common problem is a publisher broadcasting a malformed event, crashing multiple subscribers.

`Perimeter` can be used by subscribers to guard their `handle_info/2` or event handler function, ensuring they are resilient to bad data from publishers. This makes the entire system more robust.

---

This ground-up revision reframes `Perimeter` from a simple "validation library" into a "pattern library for robust Elixir development." It's now deeply connected to the core philosophy of the language, provides more powerful abstractions (`Perimeter.Interface`), and serves as an educational tool for writing better Elixir code.
</file>

<file path="PERIMETER_gem_0011.md">
Excellent. The plan is now philosophically grounded and the library's core features have been redesigned. The final step is to produce the last set of key documents that will bring this innovative system to life for developers: the **Migration Guide** and an updated **Roadmap**.

These documents are crucial because they bridge the gap between the library's ideal state and the reality of existing, "brownfield" projects. They show developers a practical, low-risk path to adoption.

---

### `guides/migration_guide.md`

# Migrating to Perimeter: A Gradual Approach

Adopting `Perimeter` doesn't require a full rewrite. It's designed to be introduced into existing Elixir applications incrementally, providing immediate value at every step. This guide outlines a safe, phased strategy for migration.

This approach is heavily inspired by the **Strangler Fig Pattern**, where new, robust code slowly and safely replaces old code.

## The Migration Philosophy: From Implicit to Explicit

The goal of migration is to move from **implicit assumptions** about your data to **explicit, enforced contracts**.

-   **Before:** Your functions defensively check data, assuming it might be wrong.
-   **After:** Your functions assertively use data, knowing it has been validated at the perimeter.

## Phase 1: Observe and Log (Weeks 1-2)

The first phase is about gaining visibility without changing any behavior.

**Step 1: Configure for `:log` Enforcement**

In your `config/config.exs`, set the default enforcement level to `:log`. This ensures that even if you accidentally use `@guard` without an option, it won't break your application.

```elixir
# config/config.exs
config :perimeter, enforcement_level: :log
```

**Step 2: Identify a Critical Perimeter**

Choose a single, important entry point to your system. A great candidate is a key Phoenix controller action or a primary function in one of your core contexts.

**Step 3: Write a "Shadow" Contract**

Define a contract that you *believe* represents the data passing through that perimeter. This is a hypothesis.

```elixir
defmodule MyApp.Accounts do
  use Perimeter

  # Our hypothesis about the shape of create_user params
  defcontract :create_user_params do
    required :email, :string
    required :password, :string
    optional :name, :string
  end

  # Apply the guard in :log mode
  @guard input: :create_user_params, enforcement: :log
  def create_user(params) do
    # ... existing legacy code ...
    # No changes to the code inside the function yet!
  end
end
```

**Step 4: Deploy and Monitor**

Deploy this change. Your application's behavior will be unchanged. However, every time `create_user/1` is called with data that *doesn't* match your contract, a detailed message will be logged.

Your logs are now a to-do list for fixing upstream data integrity issues or refining your contract.

## Phase 2: Refactor and Warn (Weeks 3-4)

Now that you have visibility, you can start cleaning up your code.

**Step 1: Refine Contracts and Fix Callers**

Using the data from your logs, fix the services that are sending malformed data. You may also discover your contract was wrong and needs to be updated. Continue this process until the log messages for your guarded function disappear.

**Step 2: Switch to `:warn` Enforcement**

Update the guard's enforcement level. This elevates the log message to a warning, making it more prominent.

```elixir
@guard input: :create_user_params, enforcement: :warn
def create_user(params) do
  # ... still the same legacy code ...
end
```

**Step 3: Refactor the "Interior"**

Now, you can refactor the *inside* of the function. Since you are confident the data is valid (because the warnings are gone), you can remove defensive code and replace it with assertive, simpler code.

**Before (Legacy Code):**
```elixir
def create_user(params) do
  email = Map.get(params, "email")
  password = Map.get(params, "password")

  if is_nil(email) or not is_binary(email) do
    {:error, :invalid_email}
  else
    # ... more checks ...
  end
end
```

**After (Refactored Interior):**
```elixir
@guard input: :create_user_params, enforcement: :warn
def create_user(params) do
  # The guard handles validation. We can be assertive.
  %User{}
  |> User.changeset(params)
  |> Repo.insert()
end
```

## Phase 3: Enforce and Solidify (Weeks 5+)

This is the final step for the migrated module.

**Step 1: Switch to `:strict` Enforcement**

Once you have refactored the interior and are confident in your contract, switch to strict enforcement. In your test and development environments, this should be the default anyway.

```elixir
@guard input: :create_user_params, enforcement: :strict
def create_user(params) do
  # ... your clean, assertive code ...
end
```

Now, any future call with invalid data will be rejected at the perimeter, protecting your core logic completely.

**Step 2: Repeat the Process**

Choose the next perimeter in your application and repeat the process, starting from Phase 1. Over time, you will build a perimeter of explicit, enforced contracts around your entire system.

## Migration for Libraries

If you are a library author, you can use `Perimeter.Interface` to manage breaking changes.

1.  Define a new `V2` interface for your behaviour.
2.  Provide an adapter that implements the `V2` interface by calling the old `V1` functions.
3.  In your library's core, check if a user's module implements the `V2` or `V1` behaviour, and use the adapter if necessary.
4.  Deprecate the `V1` behaviour, giving users a clear path to upgrade their implementations to conform to the new, contract-enforced interface.

---

### `ROADMAP.md` (Revised with the new philosophy)

# Perimeter Development Roadmap

This document outlines the planned future direction for the `Perimeter` library, guided by our core philosophy of idiomatic, pattern-based Elixir development.

## 1.0 - "Foundations of an Idiomatic System"

The 1.0 release focuses on providing a complete, robust implementation of the **Defensive Perimeter** design pattern.

-   [x] **Core Contracts:** `defcontract`, `required`, `optional` DSL.
-   [x] **Core Guarding:** `@guard` macro with configurable enforcement.
-   [x] **Core Patterns:**
    - `Perimeter.Interface` to formally support the **Strategy Pattern**.
-   [x] **Public Validator API:** `Perimeter.Validator` for manual validation.
-   [x] **Documentation:**
    - `guides/philosophy_and_principles.md`
    - `guides/design_patterns.md`
    - `guides/migration_guide.md`

## 1.x - "Ecosystem Integration"

The next series of minor releases will focus on making `Perimeter` a seamless part of the modern Elixir development toolkit.

-   **Ecto Integration:**
    - A function to derive a `Perimeter` contract directly from an `Ecto.Changeset`. This promotes a single source of truth for data validation rules.
    - `defcontract from_ecto_schema: MyApp.User` to generate a basic contract from a database schema.
-   **Phoenix Integration:**
    - A `Perimeter.Plug` for standardizing the handling of validation errors in JSON APIs.
    - `Perimeter.LiveViewHelpers` to make guarding `handle_event` and `handle_params` more ergonomic.
-   **Telemetry & Observability:**
    - A standard set of `:telemetry` events for tracking validation performance, failure rates per contract, and enforcement level activity.
    - A default `LiveDashboard` page for visualizing `Perimeter` metrics.

## 2.0 - "Intelligent Perimeters"

The next major release will explore making the library smarter and more powerful, potentially with breaking changes that simplify the API.

-   **Static Analysis and Code Generation:**
    - `mix perimeter.gen.spec`: A task that reads a contract and generates a corresponding `@spec`. This will improve Dialyzer's ability to analyze code inside the "Offensive Interior".
    - `mix perimeter.gen.tests`: A task that generates basic "happy path" and "error path" tests from a contract, bootstrapping the testing process.
-   **Next-Generation `Perimeter.Interface`:**
    - Explore ways to automatically enforce that a module implementing an interface *also* defines the required contracts, removing a manual step for the developer. This may require advanced macro-work or a new approach.
-   **Performance Enhancements:**
    - Research into runtime-compiled validators for hot-path contracts, potentially offering near-zero overhead for high-throughput systems.

This roadmap aligns the library's evolution with the needs of Elixir developers, moving from a solid philosophical foundation to deep integration and intelligent tooling.
</file>

<file path="PERIMETER_gem_0012.md">
Excellent. We've established the philosophy, redesigned the library, created the core guides, and defined the project's future. The final, crucial step is to produce the documentation that makes the library truly "innovative for greenfield Elixir development": a guide on how to architect a new application from scratch using `Perimeter`'s principles.

This document will be the capstone, tying everything together and showing developers the "happy path" from day one.

---

### `guides/greenfield_architecture.md`

# Architecting a New Elixir Application with Perimeter

This guide presents an architectural blueprint for building new, "greenfield" Elixir applications using `Perimeter` from the very beginning. By adopting these patterns, you can create a system that is robust, maintainable, and idiomatic from day one.

The architecture is built around two core concepts: **Phoenix as the Web Perimeter** and **Contexts as the Domain Perimeter**.

## The Core Architecture

A `Perimeter`-driven application consists of three primary layers:

```
+-------------------------------------------------------------------+
|                           1. The Web Layer                        |
|        (Phoenix: Controllers, LiveViews, Channels, Plugs)         |
|                                                                   |
|   <-- Perimeter Guards at this Perimeter (Validates raw input) --> |
+-------------------------------------------------------------------+
|                         2. The Domain Layer                       |
|           (Core Contexts: Accounts, Sales, Shipping)              |
|                                                                   |
|  <-- Perimeter Guards at this Perimeter (Ensures domain integrity) |
+-------------------------------------------------------------------+
|                         3. The Data Layer                         |
|                       (Ecto Schemas and Repos)                    |
+-------------------------------------------------------------------+
```

-   **The Web Layer** is responsible for handling external interactions (HTTP requests, WebSocket events). Its only job is to translate these interactions into calls to the Domain Layer.
-   **The Domain Layer** contains your business logic. It knows nothing about the web. Its functions operate on pure Elixir data structures.
-   **The Data Layer** is responsible for persistence, using Ecto to interact with the database.

**`Perimeter` is the gatekeeper between these layers.**

## Step-by-Step Greenfield Blueprint

### Step 1: Define Your Domain with Ecto and Contracts

Before writing a single line of web code, define your core data structures. For each core entity (e.g., `User`, `Order`), create three modules:

1.  **The Ecto Schema:** `lib/my_app/accounts/user.ex`
2.  **The Context:** `lib/my_app/accounts.ex`
3.  **The Contracts:** `lib/my_app/accounts/contracts.ex` (A new, dedicated module for contracts)

```elixir
# lib/my_app/accounts/user.ex
defmodule MyApp.Accounts.User do
  use Ecto.Schema
  # ... Ecto schema definition ...
end

# lib/my_app/accounts/contracts.ex
defmodule MyApp.Accounts.Contracts do
  use Perimeter.Contract
  alias MyApp.Accounts.User

  # A contract for creating a user. Notice it has no `id`.
  defcontract :create_user_params do
    required :email, :string, format: ~r/@/
    required :password, :string, min_length: 12
  end

  # A contract for the data returned by the context.
  defcontract :user_output do
    required :id, :string
    required :email, :string
    required :__struct__, :atom, in: [User]
  end
end

# lib/my_app/accounts.ex
defmodule MyApp.Accounts do
  alias MyApp.Accounts.Contracts
  alias MyApp.Repo

  # Guard the public function of your context.
  # This is the INNER perimeter. It protects your domain logic.
  @guard input: Contracts.create_user_params, output: Contracts.user_output
  def create_user(params) do
    # Inside here, `params` are guaranteed to be valid.
    # The return value will be checked against the `:user_output` contract.
    with {:ok, %User{} = user} <- # ... Ecto logic ... do
      {:ok, user}
    end
  end
end
```
By defining contracts alongside your context, you create a self-documenting, testable, and robust domain layer *before* any web code exists.

### Step 2: Build the Web Perimeter with Phoenix

Now, build the web interface that interacts with your domain.

```elixir
# lib/my_app_web/controllers/user_controller.ex
defmodule MyAppWeb.UserController do
  use MyAppWeb, :controller
  alias MyApp.Accounts
  alias MyApp.Accounts.Contracts

  # Action plugs are a great way to handle parameter loading and validation.
  plug :validate_params, [action: :create, contract: Contracts.create_user_params] when action in [:create]

  def create(conn, validated_params) do
    # The `validated_params` have already been checked by the plug.
    # This is the OUTER perimeter. It protects your web layer from bad HTTP requests.
    case Accounts.create_user(validated_params) do
      {:ok, user} ->
        conn
        |> put_status(:created)
        |> render("show.json", user: user)

      {:error, _changeset} = error ->
        # The context function returned an error. Pass it up.
        {:error, error}
    end
  end

  # A reusable validation plug.
  defp validate_params(conn, opts) do
    contract = Keyword.fetch!(opts, :contract)
    with {:ok, validated_params} <- Perimeter.Validator.validate(contract, :input, conn.params) do
      # If valid, assign the params for the controller action to use.
      assign(conn, :validated_params, validated_params)
    else
      {:error, error} ->
        # If invalid, halt the plug pipeline and send a 422 response.
        conn
        |> put_status(:unprocessable_entity)
        |> put_view(json: MyAppWeb.ErrorJSON)
        |> render("422.json", error: error)
        |> halt()
    end
  end
end
```
This two-layer guard system is incredibly robust:
1.  The **Outer Guard** (in the plug) protects your web layer from malformed JSON/params and provides immediate, clear API error messages.
2.  The **Inner Guard** (in the context) protects your domain logic, ensuring that no other part of the Elixir application (e.g., a background job, another context) can call it with invalid data.

### Step 3: Implement Pluggable Strategies with `Perimeter.Interface`

For parts of your system that require interchangeable components (e.g., payment gateways, notification services), use `Perimeter.Interface` to define the "pluggable strategy" pattern.

**1. Define the Interface:**

```elixir
# lib/my_app/notifications/notifier.ex
defmodule MyApp.Notifications.Notifier do
  use Perimeter.Interface # This defines a behaviour and contract template

  @doc "Sends a notification."
  @callback send(recipient :: any(), message :: String.t(), opts :: map()) :: :ok | {:error, term()}

  # All implementations MUST define an `:opts` contract.
  defcontract :opts do
    # Base implementations can define shared options here.
    optional :trace_id, :string
  end
end
```

**2. Create Implementations:**

```elixir
# lib/my_app/notifications/email_notifier.ex
defmodule MyApp.Notifications.EmailNotifier do
  @behaviour MyApp.Notifications.Notifier # Implement the behaviour
  use Perimeter.Contract                  # To define this module's contract

  # Define the specific options for this strategy
  defcontract :opts do
    compose MyApp.Notifications.Notifier.opts() # Compose shared options
    required :subject, :string
  end

  @impl true
  @guard input: :opts # Guard the implementation with its specific contract
  def send(recipient, message, opts) do
    # ... logic to send an email using the validated opts ...
  end
end
```

**3. Use the Strategy in Your Domain:**

```elixir
# lib/my_app/accounts.ex
defmodule MyApp.Accounts do
  # ...

  def notify_user(user, message) do
    # Get the configured notifier (e.g., from Application config)
    notifier = Application.get_env(:my_app, :notifier_impl)
    opts = # ... construct opts for the specific notifier ...

    # The call is polymorphic. The correct implementation will be called,
    # and its own guard will validate its specific opts.
    notifier.send(user.email, message, opts)
  end
end
```
This architecture creates a system that is:
-   **Decoupled:** The web layer doesn't know how the domain works, and the domain doesn't know how notifications are sent.
-   **Explicit:** Contracts at every perimeter make data flow obvious.
-   **Testable:** Each layer can be tested in isolation. You can test the domain context without needing a simulated web request. You can test a notifier strategy without needing a full user object.
-   **Resilient:** Invalid data is stopped at the earliest possible moment, protecting your core logic.

This greenfield blueprint is the culmination of the `Perimeter` philosophy. It moves beyond just "validating data" to providing a comprehensive pattern language for building truly robust, modern Elixir applications.
</file>

<file path="PERIMETER_LIBRARY_IMPLEMENTATION_GUIDE.md">
# Perimeter Library Implementation Guide

## Overview

This guide maps the evolution from the Jido type system challenges to the innovative `perimeter` library, providing a comprehensive reference for implementing the "Defensive Perimeter / Offensive Interior" pattern in Elixir.

## Document Evolution Timeline

### Phase 1: Problem Discovery
- **0001.md**: Initial dialyzer type contract investigation revealing fundamental design flaws
- **0001_final_analysis.md**: Root cause identified - polymorphic struct anti-pattern
- **jido_architectural_analysis.md**: Comprehensive analysis of the architectural mismatch

### Phase 2: Innovation Design
- **type_perimeters_design.md**: Introduction of the three-zone model
- **type_enforcement_library_spec.md**: Detailed API specifications
- **type_relationships_formal_spec.md**: Formal type system relationships

### Phase 3: Synthesis with Elixir Best Practices
- **type_safe_metaprogramming_patterns.md**: Integration with metaprogramming
- **defensive_perimeter_implementation.md**: Practical implementation patterns
- **error_handling_type_safety.md**: Type-safe error perimeters
- **migration_strategy_guide.md**: Gradual adoption path

### Phase 4: Library Evolution (Post-Valim Talk)
- **PERIMETER_gem_0010.md**: Philosophical grounding based on Valim's principles
- **PERIMETER_gem_0011.md**: Migration guide and roadmap
- **PERIMETER_gem_0012.md**: Greenfield architecture patterns

## Core Innovation: The Three-Zone Model

```
┌─────────────────────────────────────────────────┐
│            DEFENSIVE PERIMETER                  │
│  ┌───────────────────────────────────────────┐  │
│  │         TRANSITION LAYER                  │  │
│  │  ┌───────────────────────────────────┐   │  │
│  │  │    OFFENSIVE INTERIOR             │   │  │
│  │  │  (Metaprogramming Freedom)        │   │  │
│  │  └───────────────────────────────────┘   │  │
│  └───────────────────────────────────────────┘  │
└─────────────────────────────────────────────────┘
```

### Zone Characteristics

1. **Defensive Perimeter**
   - Strict type validation at API perimeters
   - Contract enforcement via `@guard` macro
   - Structured error generation

2. **Transition Layer**
   - Type transformation and normalization
   - Safe atom conversion (avoiding dynamic atom creation)
   - Default value injection

3. **Offensive Interior**
   - Unrestricted metaprogramming
   - Assertive pattern matching
   - Trust in validated data

## Key Library Components

### 1. Contract Definition System
- **Module**: `Perimeter.Contract`
- **Key Features**:
  - `defcontract/2` macro for declarative contracts
  - `required/3` and `optional/3` field definitions
  - `compose/1` for contract composition
  - `validate/1` for custom validation functions

### 2. Guard Enforcement
- **Module**: `Perimeter.Guard`
- **Key Features**:
  - `@guard` attribute macro
  - Configurable enforcement levels (`:strict`, `:warn`, `:log`)
  - Input and output validation
  - Compile-time function wrapping

### 3. Runtime Validation
- **Module**: `Perimeter.Validator`
- **Key Features**:
  - `validate/3` for manual validation
  - `validate!/3` for exception-raising validation
  - Result caching for performance
  - Structured error responses

### 4. Error Handling
- **Module**: `Perimeter.Error`
- **Key Features**:
  - Structured violation tracking
  - Path-based error location
  - Integration with Phoenix/Absinthe
  - Telemetry emission

## Anti-Pattern Solutions

### 1. Non-Assertive Pattern Matching
- **Problem**: Defensive code with unclear failure modes
- **Solution**: Contracts guarantee structure, enabling assertive matching

### 2. Dynamic Atom Creation
- **Problem**: Memory leaks from uncontrolled atom creation
- **Solution**: Explicit atom mappings in contracts with `in:` constraints

### 3. Non-Assertive Map Access
- **Problem**: Using `map[:key]` for required fields
- **Solution**: Post-validation assertive access with `map.key`

### 4. Complex else Clauses
- **Problem**: Unclear error sources in with expressions
- **Solution**: Single validation point at function entry

## Implementation Patterns

### Pattern 1: Context Perimeters
```elixir
defmodule MyApp.Accounts do
  use Perimeter
  
  defcontract :create_user_params do
    required :email, :string, format: ~r/@/
    required :password, :string, min_length: 12
  end
  
  @guard input: :create_user_params
  def create_user(params) do
    # Assertive interior
  end
end
```

### Pattern 2: Phoenix Integration
```elixir
defmodule MyAppWeb.UserController do
  use MyAppWeb, :controller
  use Perimeter
  
  plug :validate_params, contract: :create_params
  
  def create(conn, validated_params) do
    # Work with validated data
  end
end
```

### Pattern 3: GenServer Protection
```elixir
defmodule MyApp.Worker do
  use GenServer
  use Perimeter
  
  defcontract :job_params do
    required :type, :atom, in: [:sync, :async]
    required :payload, :map
  end
  
  @guard input: :job_params
  def handle_call({:process, params}, _from, state) do
    # Protected handler
  end
end
```

## Testing Strategy

### 1. Contract Testing
- Direct validation via `Perimeter.Validator`
- Property-based testing for contract coverage
- Contract composition verification

### 2. Guard Testing
- Happy path validation
- Error perimeter testing
- Enforcement level verification

### 3. Integration Testing
- Phoenix controller integration
- GenServer message validation
- Error propagation verification

## Performance Considerations

### 1. Compile-Time Optimization
- Contract compilation to pattern matches
- Static validation path generation
- Module attribute optimization

### 2. Runtime Optimization
- Validation result caching
- Lazy validation for large structures
- Fast-path for common patterns

### 3. Production Configuration
- `:log` level for monitoring
- Selective `:strict` enforcement
- Telemetry integration

## Migration Path

### For Existing Applications
1. Start with `:log` enforcement
2. Identify critical perimeters
3. Write shadow contracts
4. Fix upstream issues
5. Progress to `:warn` then `:strict`

### For New Applications
1. Design with contracts first
2. Use `:strict` in development/test
3. Guard all public APIs
4. Trust validated interiors

## Success Metrics

### Library Implementation
- All core modules compile without warnings
- 100% test coverage for public API
- Dialyzer compliance
- Documentation examples run correctly

### Integration Success
- Phoenix controller example works
- GenServer example works
- Error handling demonstrates proper structure
- Performance benchmarks show < 1% overhead

## References for Implementation

### Essential Reading Order
1. `type_perimeters_design.md` - Core innovation
2. `PERIMETER_gem_0010.md` - Philosophical foundation
3. `defensive_perimeter_implementation.md` - Practical patterns
4. `ELIXIR_1_20_0_DEV_ANTIPATTERNS.md` - Problems being solved

### Module-Specific References
- **Contract System**: `type_enforcement_library_spec.md`
- **Guard System**: `defensive_perimeter_implementation.md`
- **Error Handling**: `error_handling_type_safety.md`
- **Testing**: `PERIMETER_gem_0003.md`

## Final Implementation Notes

The `perimeter` library represents a synthesis of:
1. Solutions to real dialyzer issues in complex frameworks
2. Elixir community best practices and anti-pattern avoidance
3. José Valim's design principles for idiomatic Elixir
4. Practical patterns for large-scale applications

Success comes from focusing on the core innovation (the three-zone model) while maintaining simplicity and Elixir idioms throughout the implementation.
</file>

<file path="PERIMETER_LIBRARY_IMPLEMENTATION_PROMPTS.md">
# Perimeter Library Implementation Prompts

## Overview
This document contains a series of incremental prompts for implementing the `perimeter` library. Each prompt is self-contained, includes all necessary context, and has clear success metrics.

---

## Prompt 1: Core Contract DSL Foundation

### Context
You are implementing the `perimeter` library for Elixir, which provides runtime type validation at system perimeters. Read these references:
- **Primary**: `PERIMETER_LIBRARY_IMPLEMENTATION_GUIDE.md` sections "Core Innovation" and "Key Library Components"
- **Secondary**: `type_enforcement_library_spec.md` section on `Jido.TypeContract`

### Task
Implement the basic contract definition DSL in `lib/perimeter/contract.ex`:

1. Create the `defcontract/2` macro that:
   - Accepts a name (atom) and a do block
   - Stores contract definitions in module attributes
   - Generates a `__contract__/1` function

2. Implement `required/3` and `optional/3` macros that:
   - Accept field name, type, and options
   - Build field specifications

3. Create basic type atoms:
   - `:string`, `:integer`, `:boolean`, `:atom`, `:map`

### Success Metrics
```elixir
# This should compile without warnings:
defmodule TestContract do
  use Perimeter.Contract
  
  defcontract :user do
    required :name, :string
    optional :age, :integer
  end
end

# This should return contract data:
TestContract.__contract__(:user)
```

### Manual Verification
1. Run `mix compile --warnings-as-errors`
2. Check that `__contract__/1` returns a data structure with field definitions
3. Verify no compiler warnings about undefined macros

---

## Prompt 2: Contract Validation Engine

### Context
Building on Prompt 1's contract DSL. Read these references:
- **Primary**: `defensive_perimeter_implementation.md` section "Contract Validation Engine"
- **Secondary**: `type_contract_best_practices.md` section "Fail Fast with Clear Messages"

### Task
Implement the validation engine in `lib/perimeter/validator.ex`:

1. Create `validate/3` function that:
   - Takes module, contract name, and data map
   - Returns `{:ok, data}` or `{:error, %Perimeter.Error{}}`
   - Validates required fields exist
   - Validates optional fields if present
   - Checks basic type constraints

2. Implement type validators for:
   - `:string` - `is_binary/1`
   - `:integer` - `is_integer/1`
   - `:boolean` - `is_boolean/1`
   - `:atom` - `is_atom/1`
   - `:map` - `is_map/1`

3. Create `Perimeter.Error` struct with:
   - `violations` list
   - Each violation has: `field`, `error`, `value`, `path`

### Success Metrics
```elixir
# Valid data passes:
{:ok, _} = Perimeter.Validator.validate(TestContract, :user, %{name: "John"})

# Invalid data fails with structured error:
{:error, %Perimeter.Error{violations: [
  %{field: :name, error: "is required"}
]}} = Perimeter.Validator.validate(TestContract, :user, %{})

# Type mismatch caught:
{:error, %Perimeter.Error{violations: [
  %{field: :name, error: "expected string, got integer"}
]}} = Perimeter.Validator.validate(TestContract, :user, %{name: 123})
```

### Manual Verification
1. Create test module with various contracts
2. Test validation with valid/invalid data
3. Inspect error structures for clarity
4. Run dialyzer to check type specifications

---

## Prompt 3: Field Constraints Implementation

### Context
Extending the validation engine with constraints. Read:
- **Primary**: `type_enforcement_library_spec.md` section on field options
- **Secondary**: `ELIXIR_1_20_0_DEV_ANTIPATTERNS.md` section "Dynamic Atom Creation"

### Task
Add constraint validation to the validator:

1. String constraints:
   - `min_length:` and `max_length:`
   - `format:` (regex pattern)

2. Number constraints:
   - `min:` and `max:`

3. Atom constraints:
   - `in:` (list of allowed atoms)
   - Prevent dynamic atom creation

4. List constraints:
   - `min_items:` and `max_items:`

### Success Metrics
```elixir
defmodule ConstraintTest do
  use Perimeter.Contract
  
  defcontract :validated do
    required :email, :string, format: ~r/@/
    required :age, :integer, min: 18, max: 100
    required :status, :atom, in: [:active, :inactive]
  end
end

# Constraints work:
{:ok, _} = validate(ConstraintTest, :validated, %{
  email: "test@example.com",
  age: 25,
  status: :active
})

# Format constraint fails:
{:error, %{violations: [%{field: :email, error: "invalid format"}]}} = 
  validate(ConstraintTest, :validated, %{email: "notanemail", age: 25, status: :active})
```

### Manual Verification
1. Test each constraint type individually
2. Verify constraint combinations work
3. Check that `in:` constraint prevents atom creation attacks
4. Ensure helpful error messages

---

## Prompt 4: Guard Macro Foundation

### Context
Implementing the `@guard` attribute macro. Read:
- **Primary**: `defensive_perimeter_implementation.md` section "Perimeter Guard Module"
- **Secondary**: `PERIMETER_gem_0002.md` section on guard mechanics

### Task
Create `lib/perimeter/guard.ex` with:

1. Basic `@guard` attribute that:
   - Stores guard configuration
   - Triggers function wrapping at compile time

2. Function wrapping that:
   - Intercepts the original function
   - Validates first argument against input contract
   - Calls original function if valid
   - Returns `{:error, %Perimeter.Error{}}` if invalid

3. Support `:input` option only (not `:output` yet)

### Success Metrics
```elixir
defmodule GuardedModule do
  use Perimeter
  
  defcontract :params do
    required :id, :integer
  end
  
  @guard input: :params
  def process(params) do
    {:ok, params.id * 2}
  end
end

# Valid input works:
{:ok, 10} = GuardedModule.process(%{id: 5})

# Invalid input caught:
{:error, %Perimeter.Error{}} = GuardedModule.process(%{id: "not-an-int"})
```

### Manual Verification
1. Use `IO.inspect` to verify guard intercepted call
2. Check that original function body only runs with valid data
3. Test with multiple function clauses
4. Verify compilation performance is reasonable

---

## Prompt 5: Enforcement Levels

### Context
Adding configurable enforcement. Read:
- **Primary**: `migration_strategy_guide.md` section "Progressive Type Enforcement"
- **Secondary**: `PERIMETER_gem_0011.md` section on enforcement levels

### Task
Implement enforcement level system:

1. Add configuration:
   ```elixir
   config :perimeter, enforcement_level: :strict
   ```

2. Support three levels:
   - `:strict` - Return error, don't call function
   - `:warn` - Log warning, call function anyway
   - `:log` - Log info, call function anyway

3. Add `:enforcement` option to `@guard`:
   ```elixir
   @guard input: :params, enforcement: :log
   ```

4. Create `Perimeter.Config` module for runtime configuration

### Success Metrics
```elixir
# With :log enforcement
Application.put_env(:perimeter, :enforcement_level, :log)

# Invalid data logs but continues:
capture_log(fn ->
  {:ok, nil} = GuardedModule.process(%{})  # Function runs despite invalid data
end) =~ "Perimeter contract violation"

# With :strict enforcement
Application.put_env(:perimeter, :enforcement_level, :strict)

# Invalid data returns error:
{:error, %Perimeter.Error{}} = GuardedModule.process(%{})
```

### Manual Verification
1. Test each enforcement level
2. Verify log output format is helpful
3. Check that per-guard enforcement overrides global
4. Test configuration changes at runtime

---

## Prompt 6: Nested Contracts

### Context
Supporting nested data structures. Read:
- **Primary**: `type_contract_best_practices.md` section "Use Composition"
- **Secondary**: Nested contract examples in `PERIMETER_LIBRARY_IMPLEMENTATION_GUIDE.md`

### Task
Add support for nested contracts:

1. Map nesting:
   ```elixir
   required :address, :map do
     required :street, :string
     optional :zip, :string
   end
   ```

2. List of maps:
   ```elixir
   required :items, {:list, :map} do
     required :id, :integer
     required :name, :string
   end
   ```

3. Update validator to handle nested validation
4. Ensure error paths are correct for nested fields

### Success Metrics
```elixir
defcontract :order do
  required :id, :integer
  required :customer, :map do
    required :name, :string
    required :email, :string
  end
  required :items, {:list, :map} do
    required :sku, :string
    required :quantity, :integer
  end
end

# Nested validation works:
{:ok, _} = validate(TestMod, :order, %{
  id: 1,
  customer: %{name: "John", email: "j@example.com"},
  items: [%{sku: "ABC", quantity: 2}]
})

# Nested errors have correct paths:
{:error, %{violations: [
  %{field: :email, path: [:customer, :email], error: "is required"}
]}} = validate(TestMod, :order, %{
  id: 1,
  customer: %{name: "John"},
  items: []
})
```

### Manual Verification
1. Test deeply nested structures (3+ levels)
2. Verify path construction is correct
3. Test empty lists and maps
4. Check performance with large nested structures

---

## Prompt 7: Custom Validators

### Context
Adding custom validation functions. Read:
- **Primary**: `type_contract_best_practices.md` section "Separate Validation from Business Logic"
- **Secondary**: `defensive_perimeter_implementation.md` Custom validator examples 

### Task
Implement custom validation support:

1. Add `validate/1` macro to contract DSL:
   ```elixir
   defcontract :user do
     required :password, :string
     required :password_confirmation, :string
     validate :passwords_match
   end
   ```

2. Custom validators should:
   - Receive the validated data map
   - Return `:ok` or `{:error, violation_map}`
   - Run after field validation
   - Have access to all fields

3. Support multiple validators per contract

### Success Metrics
```elixir
defmodule CustomTest do
  use Perimeter.Contract
  
  defcontract :registration do
    required :password, :string, min_length: 8
    required :password_confirmation, :string
    validate :passwords_match
  end
  
  defp passwords_match(%{password: p, password_confirmation: pc}) do
    if p == pc do
      :ok
    else
      {:error, %{field: :password_confirmation, error: "does not match password"}}
    end
  end
end

# Custom validation works:
{:error, %{violations: [
  %{field: :password_confirmation, error: "does not match password"}
]}} = validate(CustomTest, :registration, %{
  password: "secret123",
  password_confirmation: "different"
})
```

### Manual Verification
1. Test validator execution order
2. Verify validators can access all fields
3. Test multiple validators on same contract
4. Ensure validators can't modify data

---

## Prompt 8: Contract Composition

### Context
Implementing contract reuse. Read:
- **Primary**: `type_contract_best_practices.md` section "Compose, Don't Repeat"
- **Secondary**: `PERIMETER_LIBRARY_IMPLEMENTATION_GUIDE.md` Examples of shared contracts

### Task
Add `compose/1` macro for contract composition:

1. Allow composing single or multiple contracts:
   ```elixir
   defcontract :timestamped do
     compose :timestamps
     required :title, :string
   end
   ```

2. Handle field conflicts (last wins)
3. Compose validators as well
4. Support cross-module composition

### Success Metrics
```elixir
defmodule SharedContracts do
  use Perimeter.Contract
  
  defcontract :timestamps do
    required :inserted_at, :datetime
    required :updated_at, :datetime
  end
end

defmodule UserContracts do
  use Perimeter.Contract
  import SharedContracts
  
  defcontract :user do
    required :email, :string
    compose :timestamps
  end
end

# Composition works:
{:ok, _} = validate(UserContracts, :user, %{
  email: "test@example.com",
  inserted_at: DateTime.utc_now(),
  updated_at: DateTime.utc_now()
})

# Missing composed field caught:
{:error, %{violations: [%{field: :inserted_at}]}} = 
  validate(UserContracts, :user, %{email: "test@example.com"})
```

### Manual Verification
1. Test single and multiple composition
2. Verify field override behavior
3. Test circular composition detection
4. Check cross-module imports work

---

## Prompt 9: Phoenix Integration

### Context
Creating Phoenix-specific helpers. Read:
- **Primary**: `greenfield_architecture.md` section "Build the Web Perimeter"
- **Secondary**: `PERIMETER_LIBRARY_IMPLEMENTATION_GUIDE.md` Phoenix controller examples

### Task
Create `lib/perimeter/phoenix.ex` with:

1. Plug for parameter validation:
   ```elixir
   plug Perimeter.Phoenix.ValidateParams, contract: :create_user
   ```

2. FallbackController helper for errors
3. Helper for validated params access
4. JSON error formatting

### Success Metrics
```elixir
defmodule TestController do
  use Phoenix.Controller
  use Perimeter
  
  plug Perimeter.Phoenix.ValidateParams, 
    contract: :create_params when action == :create
  
  defcontract :create_params do
    required :user, :map do
      required :email, :string
    end
  end
  
  def create(conn, _params) do
    # Validated params available
    validated = conn.assigns.perimeter_params
    json(conn, %{email: validated.user.email})
  end
end

# Invalid params return 422:
conn = conn(:post, "/users", %{user: %{}})
conn = TestController.call(conn, :create)
assert conn.status == 422
assert conn.resp_body =~ "email is required"
```

### Manual Verification
1. Test with real Phoenix app
2. Verify plug pipeline integration
3. Test error response format
4. Check performance impact

---

## Prompt 10: Documentation and Examples

### Context
Creating comprehensive documentation. Read:
- **Primary**: All PERIMETER_gem_* files for structure
- **Secondary**: `PERIMETER_LIBRARY_IMPLEMENTATION_GUIDE.md`

### Task
Create documentation:

1. Complete README.md with:
   - Philosophy section
   - Quick start example
   - Installation instructions

2. Add @moduledoc to all modules
3. Add @doc to all public functions
4. Create `examples/` directory with:
   - Phoenix app example
   - GenServer example
   - Plain module example

### Success Metrics
```bash
# Documentation builds without warnings:
mix docs

# Examples run without errors:
cd examples/phoenix_app && mix test
cd examples/genserver && mix test

# Doctests pass:
mix test --only doctest
```

### Manual Verification
1. Review generated docs for clarity
2. Test all code examples work
3. Check cross-references are correct
4. Verify examples demonstrate key patterns

---

## Prompt 11: Performance Optimization

### Context
Optimizing for production use. Read:
- **Primary**: `defensive_perimeter_implementation.md` section "Performance Optimization"
- **Secondary**: `PERIMETER_CACHING_STRATEGIES.md` Caching strategies

### Task
Add performance optimizations:

1. Compile contracts at compile-time into optimized validators
2. Add simple validation result caching
3. Implement fast paths for common patterns
4. Add benchmarks in `bench/` directory

### Success Metrics
```elixir
# Benchmark shows < 1% overhead:
Benchee.run(%{
  "without_perimeter" => fn -> 
    MyModule.unguarded_function(%{id: 1})
  end,
  "with_perimeter" => fn ->
    MyModule.guarded_function(%{id: 1})
  end
})

# Results show minimal overhead:
# with_perimeter is at most 1.01x slower than without_perimeter
```

### Manual Verification
1. Run benchmarks with various data sizes
2. Profile memory usage
3. Test cache hit rates
4. Verify no memory leaks

---

## Prompt 12: Final Integration Tests

### Context
Ensuring everything works together. Read:
- **Primary**: Testing sections from all guides
- **Secondary**: `PERIMETER_LIBRARY_IMPLEMENTATION_GUIDE.md` success metrics

### Task
Create comprehensive integration tests:

1. Full Phoenix application test
2. GenServer with guards test  
3. Multi-module contract sharing test
4. Error propagation test
5. Configuration change test

### Success Metrics
```bash
# All tests pass:
mix test

# Dialyzer passes:
mix dialyzer

# Credo passes:
mix credo --strict

# Coverage is 100% for public API:
mix test --cover
```

### Manual Verification
1. Review test coverage report
2. Manually test with a real app
3. Check all examples still work
4. Verify no regression in previous functionality

---

## Implementation Order and Dependencies

1. **Prompts 1-2**: Core foundation (must be done first)
2. **Prompts 3-4**: Extended functionality (requires 1-2)
3. **Prompts 5-6**: Advanced features (requires 3-4)
4. **Prompts 7-8**: Composition features (requires 1-6)
5. **Prompt 9**: Framework integration (requires 1-8)
6. **Prompts 10-12**: Polish and optimization (requires all previous)

## Notes for Manual Review

After each prompt:
1. Run `mix compile --warnings-as-errors`
2. Run `mix format --check-formatted`
3. Run `mix dialyzer` (after prompt 4)
4. Commit working code before next prompt
5. Tag successful milestone implementations

The library should be shippable after Prompt 9, with 10-12 adding polish and performance.
</file>

<file path="type_contract_best_practices.md">
# Type Contract Best Practices for Elixir

## Overview

This guide establishes best practices for defining and using type contracts in Elixir, focusing on avoiding common antipatterns while maintaining code clarity and performance. These practices build upon the "Defensive Perimeter / Offensive Interior" pattern to create maintainable, type-safe systems.

## Contract Definition Best Practices

### 1. Prefer Explicit Over Implicit Contracts

**Good Practice**: Define contracts that clearly express intent

```elixir
defmodule UserContracts do
  use Jido.TypeContract
  
  # Explicit about what constitutes a valid user
  defcontract :user_registration do
    required :email, :string, format: ~r/^[^@]+@[^@]+$/
    required :password, :string, min_length: 8
    required :terms_accepted, :boolean, equals: true
    optional :name, :string, max_length: 100
    
    validate :password_complexity
  end
  
  defp password_complexity(%{password: password}) do
    if password =~ ~r/[A-Z]/ && password =~ ~r/[0-9]/ do
      :ok
    else
      {:error, %{field: :password, error: "must contain uppercase and number"}}
    end
  end
end
```

**Antipattern Avoided**: Non-Assertive Pattern Matching

```elixir
# Bad: Accepts any map without validation
def register_user(params) do
  # Hoping the right fields exist...
  %{email: params["email"], password: params["password"]}
end

# Good: Explicit contract enforcement
@guard input: :user_registration
def register_user(params) do
  # We know these fields exist and are valid
  %{email: email, password: password} = params
end
```

### 2. Use Composition for Complex Contracts

**Good Practice**: Build complex contracts from simple, reusable components

```elixir
defmodule SharedContracts do
  use Jido.TypeContract
  
  # Basic building blocks
  defcontract :email do
    required :email, :string, format: ~r/@/
  end
  
  defcontract :timestamps do
    required :created_at, :datetime
    required :updated_at, :datetime
  end
  
  defcontract :pagination do
    optional :page, :integer, min: 1, default: 1
    optional :per_page, :integer, min: 1, max: 100, default: 20
  end
  
  # Composed contract
  defcontract :user_query do
    compose [:email, :pagination]
    optional :include_deleted, :boolean, default: false
  end
end
```

### 3. Avoid Over-Constraining Contracts

**Good Practice**: Balance strictness with flexibility

```elixir
defmodule FlexibleContracts do
  use Jido.TypeContract
  
  # Too rigid - couples to specific implementation
  defcontract :overly_strict_address do
    required :street_number, :integer
    required :street_name, :string
    required :city, :string
    required :state, :string, length: 2
    required :zip, :string, format: ~r/^\d{5}$/
  end
  
  # Better - allows for international addresses
  defcontract :flexible_address do
    required :line1, :string, min_length: 1
    optional :line2, :string
    required :city, :string, min_length: 1
    required :country_code, :string, length: 2
    optional :postal_code, :string  # Format varies by country
    optional :state_province, :string
    
    validate :country_specific_validation
  end
end
```

### 4. Use Semantic Field Names

**Good Practice**: Choose field names that express domain concepts

```elixir
defmodule DomainContracts do
  use Jido.TypeContract
  
  # Poor naming
  defcontract :bad_transaction do
    required :amt, :decimal
    required :dt, :datetime
    required :st, :integer
  end
  
  # Clear, semantic naming
  defcontract :transaction do
    required :amount_cents, :integer, min: 0
    required :occurred_at, :datetime
    required :status, :atom, in: [:pending, :completed, :failed]
    required :currency, :string, length: 3
  end
}
```

## Contract Validation Patterns

### 1. Fail Fast with Clear Messages

**Good Practice**: Provide actionable error messages

```elixir
defmodule ValidationPatterns do
  use Jido.TypeContract
  
  defcontract :order do
    required :items, {:list, :order_item}, min_items: 1
    required :shipping_address, :map
    
    validate :total_within_limits
  end
  
  defcontract :order_item do
    required :product_id, :string
    required :quantity, :integer, min: 1
    required :unit_price_cents, :integer, min: 0
  end
  
  defp total_within_limits(%{items: items}) do
    total = Enum.sum(for item <- items, do: item.quantity * item.unit_price_cents)
    
    cond do
      total == 0 ->
        {:error, %{
          field: :items,
          error: "order total cannot be zero",
          hint: "Ensure items have valid prices and quantities"
        }}
      
      total > 1_000_000_00 ->
        {:error, %{
          field: :items,
          error: "order total exceeds maximum ($1,000,000)",
          value: total,
          max: 1_000_000_00
        }}
      
      true ->
        :ok
    end
  end
end
```

### 2. Progressive Contract Validation

**Good Practice**: Validate in stages for better performance and error reporting

```elixir
defmodule ProgressiveValidation do
  use Jido.TypeContract
  
  # Stage 1: Basic structure validation
  defcontract :import_file_basic do
    required :filename, :string, format: ~r/\.csv$/
    required :size_bytes, :integer, max: 100_000_000  # 100MB
  end
  
  # Stage 2: Content validation (after basic passes)
  defcontract :import_file_content do
    required :headers, {:list, :string}, min_items: 1
    required :row_count, :integer, min: 1
    required :encoding, :atom, in: [:utf8, :utf16, :latin1]
  end
  
  # Use progressively
  def validate_import(file_info) do
    with {:ok, _} <- validate_contract(:import_file_basic, file_info),
         {:ok, content} <- read_file_headers(file_info),
         {:ok, _} <- validate_contract(:import_file_content, content) do
      {:ok, :valid}
    end
  end
end
```

### 3. Context-Aware Validation

**Good Practice**: Contracts that adapt based on context

```elixir
defmodule ContextualContracts do
  use Jido.TypeContract
  
  defcontract :user_update do
    optional :email, :string, format: ~r/@/
    optional :name, :string
    optional :role, :atom
    
    # Different validation based on who's updating
    validate {:role_change_allowed, :context}
  end
  
  defp role_change_allowed(params, context) do
    case params[:role] do
      nil -> 
        :ok
      new_role ->
        if context.current_user.role == :admin do
          :ok
        else
          {:error, %{
            field: :role,
            error: "only admins can change roles",
            current_user_role: context.current_user.role
          }}
        end
    end
  end
end
```

## Performance Best Practices

### 1. Compile-Time Contract Optimization

**Good Practice**: Move validation logic to compile time when possible

```elixir
defmodule OptimizedContracts do
  use Jido.TypeContract
  
  # Compile-time constant validation
  @valid_currencies ~w(USD EUR GBP JPY CNY)
  @valid_statuses [:draft, :published, :archived]
  
  defcontract :product do
    required :price_cents, :integer, min: 0
    required :currency, :string, in: @valid_currencies
    required :status, :atom, in: @valid_statuses
  end
  
  # Generate optimized validators at compile time
  for currency <- @valid_currencies do
    def valid_currency?(unquote(currency)), do: true
  end
  def valid_currency?(_), do: false
end
```

### 2. Lazy Validation for Large Structures

**Good Practice**: Validate only what's needed

```elixir
defmodule LazyValidation do
  use Jido.TypeContract
  
  defcontract :large_dataset do
    required :metadata, :map
    required :data, {:lazy, :validate_data_chunk}
    
    validate :check_data_format
  end
  
  # Only validate accessed portions
  def validate_data_chunk(data, accessed_indices) do
    accessed_indices
    |> Enum.map(&Enum.at(data, &1))
    |> Enum.all?(&valid_data_point?/1)
  end
end
```

### 3. Cached Contract Validation

**Good Practice**: Cache validation results for immutable data

```elixir
defmodule CachedValidation do
  use Jido.TypeContract
  
  @ttl_seconds 300  # 5 minutes
  
  defcontract :api_response do
    required :status, :integer, in: 200..299
    required :body, :map
    required :headers, :map
    
    validate {:check_rate_limits, :cached}
  end
  
  defp check_rate_limits(params, :cached) do
    cache_key = :crypto.hash(:sha256, :erlang.term_to_binary(params))
    
    case :ets.lookup(:validation_cache, cache_key) do
      [{_, result, expiry}] when expiry > System.monotonic_time() ->
        result
      _ ->
        result = do_check_rate_limits(params)
        expiry = System.monotonic_time() + @ttl_seconds
        :ets.insert(:validation_cache, {cache_key, result, expiry})
        result
    end
  end
end
```

## Integration Best Practices

### 1. Contract Documentation

**Good Practice**: Self-documenting contracts

```elixir
defmodule DocumentedContracts do
  use Jido.TypeContract
  
  @doc """
  Contract for user profile updates.
  
  ## Required Fields
  - None (all fields optional for updates)
  
  ## Optional Fields
  - `:bio` - User biography (max 500 chars)
  - `:avatar_url` - Valid URL to avatar image
  - `:preferences` - User preference map
  
  ## Validations
  - Bio must not contain profanity
  - Avatar URL must be HTTPS
  - At least one field must be present
  """
  defcontract :profile_update do
    optional :bio, :string, max_length: 500
    optional :avatar_url, :string, format: ~r/^https:\/\//
    optional :preferences, :map do
      optional :theme, :atom, in: [:light, :dark, :auto]
      optional :notifications, :boolean
    end
    
    validate :at_least_one_field
    validate :bio_appropriate
  end
end
```

### 2. Contract Testing Helpers

**Good Practice**: Provide test utilities for contracts

```elixir
defmodule ContractTestHelpers do
  defmacro assert_contract_valid(contract, data) do
    quote do
      case validate_contract(unquote(contract), unquote(data)) do
        {:ok, _} -> 
          :ok
        {:error, violations} ->
          flunk """
          Contract validation failed:
          #{format_violations(violations)}
          
          Data provided:
          #{inspect(unquote(data), pretty: true)}
          """
      end
    end
  end
  
  defmacro assert_contract_invalid(contract, data, expected_field) do
    quote do
      case validate_contract(unquote(contract), unquote(data)) do
        {:error, violations} ->
          violated_fields = Enum.map(violations, & &1.field)
          assert unquote(expected_field) in violated_fields
        {:ok, _} ->
          flunk "Expected contract validation to fail for field: #{unquote(expected_field)}"
      end
    end
  end
end
```

### 3. Contract Versioning

**Good Practice**: Support contract evolution

```elixir
defmodule VersionedContracts do
  use Jido.TypeContract
  
  # Current version
  defcontract :user_v2 do
    required :id, :string
    required :email, :string
    required :profile, :map
    optional :preferences, :map
  end
  
  # Legacy support
  defcontract :user_v1 do
    required :id, :string
    required :email, :string
    optional :name, :string
  end
  
  # Migration helper
  def migrate_user_v1_to_v2(v1_user) do
    %{
      id: v1_user.id,
      email: v1_user.email,
      profile: %{name: v1_user[:name] || ""},
      preferences: %{}
    }
  end
  
  # Auto-upgrade in validation
  def validate_user(data) do
    case validate_contract(:user_v2, data) do
      {:ok, _} = result -> 
        result
      {:error, _} ->
        # Try v1 and migrate
        with {:ok, v1_data} <- validate_contract(:user_v1, data) do
          v2_data = migrate_user_v1_to_v2(v1_data)
          {:ok, v2_data}
        end
    end
  end
end
```

## Common Pitfalls and Solutions

### 1. Over-Validation

**Pitfall**: Validating the same data multiple times

```elixir
# Bad: Redundant validation
def process_order(params) do
  with {:ok, _} <- validate_contract(:order, params),
       {:ok, _} <- validate_items(params.items),  # Items already validated!
       {:ok, _} <- validate_shipping(params.shipping) do  # Shipping already validated!
    # ...
  end
end

# Good: Trust validated data
def process_order(params) do
  with {:ok, validated} <- validate_contract(:order, params) do
    # Trust that validated.items and validated.shipping are valid
    process_validated_order(validated)
  end
end
```

### 2. Contract Sprawl

**Pitfall**: Too many similar contracts

```elixir
# Bad: Separate contract for each minor variation
defcontract :user_create
defcontract :user_update  
defcontract :user_admin_create
defcontract :user_admin_update
defcontract :user_import

# Good: Parameterized contracts
defcontract :user, mode do
  case mode do
    :create ->
      required :email, :string
      required :password, :string
    :update ->
      optional :email, :string
      optional :password, :string
    :import ->
      required :email, :string
      optional :external_id, :string
  end
  
  # Shared validations
  validate :email_format
end
```

### 3. Mixing Business Logic with Validation

**Pitfall**: Contracts that do too much

```elixir
# Bad: Business logic in contract
defcontract :order do
  required :items, {:list, :item}
  
  validate :calculate_tax  # Don't do this!
  validate :check_inventory  # Don't do this!
end

# Good: Pure validation
defcontract :order do
  required :items, {:list, :item}, min_items: 1
  required :shipping_country, :string, length: 2
  
  validate :items_have_valid_products
end

# Business logic separate
def process_order(validated_order) do
  with {:ok, tax} <- calculate_tax(validated_order),
       {:ok, _} <- check_inventory(validated_order.items) do
    # ...
  end
end
```

## Summary of Best Practices

1. **Be Explicit**: Define clear contracts that express intent
2. **Compose, Don't Repeat**: Build complex contracts from simple ones
3. **Fail Fast**: Validate at perimeters with clear error messages
4. **Trust the Interior**: Don't re-validate already validated data
5. **Optimize Wisely**: Use compile-time optimization and caching
6. **Document Well**: Self-documenting contracts with examples
7. **Test Thoroughly**: Provide test helpers and property tests
8. **Version Carefully**: Support contract evolution
9. **Keep It Pure**: Separate validation from business logic
10. **Avoid Sprawl**: Use parameterized contracts for variations

By following these practices, you create a type-safe system that leverages Elixir's strengths while avoiding common pitfalls and antipatterns.
</file>

<file path="type_enforcement_library_spec.md">
# Jido Type Enforcement Library Specification

## Overview

The Jido Type Enforcement Library provides a practical, lightweight system for runtime type validation in Elixir applications. It implements the "Defensive Perimeter / Offensive Interior" pattern, allowing unrestricted metaprogramming within type-safe perimeters.

## Core Modules

### 1. `Jido.TypeContract`

**Purpose**: Define and register type contracts at compile time.

```elixir
defmodule Jido.TypeContract do
  @moduledoc """
  Provides macros for defining type contracts that are enforced at module perimeters.
  Contracts are compiled into efficient validation functions.
  """
  
  @type contract_name :: atom()
  @type field_spec :: {atom(), field_type(), keyword()}
  @type field_type :: :string | :atom | :integer | :float | :decimal | :boolean | 
                      :date | :datetime | :map | :list | {:list, field_type()} |
                      :any | module()
  
  @doc """
  Defines a type contract with field specifications.
  
  ## Examples
  
      defcontract :user_input do
        required :name, :string, min_length: 1, max_length: 100
        required :age, :integer, min: 0, max: 150
        optional :email, :string, format: ~r/@/
        
        optional :address, :map do
          required :street, :string
          required :city, :string
          optional :postal_code, :string, format: ~r/^\d{5}$/
        end
        
        validate :custom_validation
      end
  """
  defmacro defcontract(name, do: block)
  
  @doc """
  Defines a required field in a contract.
  """
  defmacro required(field_name, field_type, opts \\ [])
  
  @doc """
  Defines an optional field in a contract.
  """
  defmacro optional(field_name, field_type, opts \\ [])
  
  @doc """
  Adds a custom validation function to the contract.
  """
  defmacro validate(function_name)
  
  @doc """
  Composes multiple contracts together.
  """
  defmacro compose(contract_names)
end
```

### 2. `Jido.PerimeterGuard`

**Purpose**: Enforce contracts at function perimeters with minimal overhead.

```elixir
defmodule Jido.PerimeterGuard do
  @moduledoc """
  Provides perimeter enforcement for type contracts with configurable
  validation levels and detailed error reporting.
  """
  
  @type validation_result :: {:ok, term()} | {:error, violations()}
  @type violations :: [violation()]
  @type violation :: %{
    field: atom(),
    value: term(),
    error: String.t(),
    path: [atom()]
  }
  
  @doc """
  Guards a function perimeter with input/output contracts.
  
  ## Options
  
  - `:input` - Input contract name
  - `:output` - Output contract name  
  - `:on_violation` - :error | :warn | :log | :ignore
  - `:transform` - Function to transform input before validation
  
  ## Example
  
      @guard input: :user_input, output: :user_result
      def create_user(params, context) do
        # Implementation
      end
  """
  defmacro guard(opts \\ [])
  
  @doc """
  Validates data against a contract.
  """
  @spec validate(module(), contract_name :: atom(), data :: map()) :: validation_result()
  def validate(module, contract_name, data)
  
  @doc """
  Validates and transforms data in a single pass.
  """
  @spec validate_and_transform(module(), contract_name :: atom(), data :: map()) :: 
    {:ok, transformed :: map()} | {:error, violations()}
  def validate_and_transform(module, contract_name, data)
  
  @doc """
  Returns a human-readable error message for violations.
  """
  @spec format_violations(violations()) :: String.t()
  def format_violations(violations)
end
```

### 3. `Jido.TypeShape`

**Purpose**: Define reusable, composable type shapes.

```elixir
defmodule Jido.TypeShape do
  @moduledoc """
  Provides a way to define reusable type shapes that can be
  composed and validated efficiently.
  """
  
  @type t :: %__MODULE__{
    name: atom(),
    fields: map(),
    validators: [validator()],
    transformers: [transformer()],
    metadata: map()
  }
  
  @type validator :: (map() -> {:ok, map()} | {:error, String.t()})
  @type transformer :: (map() -> map())
  
  @doc """
  Creates a new type shape.
  
  ## Example
  
      address_shape = shape(:address,
        street: [type: :string, required: true],
        city: [type: :string, required: true],
        postal_code: [type: :string, format: ~r/^\d{5}$/]
      )
  """
  @spec shape(atom(), keyword()) :: t()
  def shape(name, fields)
  
  @doc """
  Adds a validator to a shape.
  """
  @spec add_validator(t(), validator()) :: t()
  def add_validator(shape, validator)
  
  @doc """
  Adds a transformer to a shape.
  """  
  @spec add_transformer(t(), transformer()) :: t()
  def add_transformer(shape, transformer)
  
  @doc """
  Composes multiple shapes into one.
  """
  @spec compose([t()]) :: t()
  def compose(shapes)
  
  @doc """
  Validates data against a shape.
  """
  @spec validate(t(), map()) :: {:ok, map()} | {:error, violations()}
  def validate(shape, data)
end
```

### 4. `Jido.Runtime.TypeValidator`

**Purpose**: High-performance runtime validation with caching.

```elixir
defmodule Jido.Runtime.TypeValidator do
  @moduledoc """
  GenServer that provides cached, optimized runtime type validation.
  Builds validation paths at startup for maximum performance.
  """
  
  use GenServer
  
  @type validation_stats :: %{
    total_validations: non_neg_integer(),
    cache_hits: non_neg_integer(),
    cache_misses: non_neg_integer(),
    average_validation_time: float()
  }
  
  @doc """
  Starts the type validator with options.
  
  ## Options
  
  - `:cache_size` - Maximum number of cached validations (default: 1000)
  - `:ttl` - Cache TTL in milliseconds (default: :infinity)
  - `:preload` - List of {module, contract} to preload
  """
  @spec start_link(keyword()) :: GenServer.on_start()
  def start_link(opts \\ [])
  
  @doc """
  Validates data against a contract with caching.
  """
  @spec validate(module(), atom(), map()) :: {:ok, map()} | {:error, violations()}
  def validate(module, contract_name, data)
  
  @doc """
  Validates asynchronously for non-blocking validation.
  """
  @spec validate_async(module(), atom(), map()) :: Task.t()
  def validate_async(module, contract_name, data)
  
  @doc """
  Returns validation statistics.
  """
  @spec stats() :: validation_stats()
  def stats()
  
  @doc """
  Clears the validation cache.
  """
  @spec clear_cache() :: :ok
  def clear_cache()
end
```

### 5. `Jido.Dev.TypeChecker`

**Purpose**: Enhanced development-time type checking.

```elixir
defmodule Jido.Dev.TypeChecker do
  @moduledoc """
  Development-time type checker that provides detailed analysis
  and reporting of type violations.
  """
  
  @type check_result :: %{
    module: module(),
    violations: [violation()],
    warnings: [warning()],
    suggestions: [suggestion()]
  }
  
  @type violation :: %{type: atom(), message: String.t(), location: location()}
  @type warning :: %{type: atom(), message: String.t(), location: location()}
  @type suggestion :: %{type: atom(), message: String.t(), fix: String.t()}
  @type location :: {file :: String.t(), line :: pos_integer()}
  
  @doc """
  Enables type checking for a module in development.
  
  ## Example
  
      defmodule MyModule do
        use Jido.Dev.TypeChecker, strict: true
      end
  """
  defmacro __using__(opts)
  
  @doc """
  Analyzes a module for type violations.
  """
  @spec analyze(module()) :: check_result()
  def analyze(module)
  
  @doc """
  Analyzes all modules in an application.
  """
  @spec analyze_app(atom()) :: [check_result()]
  def analyze_app(app_name)
  
  @doc """
  Generates a type safety report.
  """
  @spec generate_report([check_result()]) :: String.t()
  def generate_report(results)
end
```

### 6. `Jido.TypeEnforcement`

**Purpose**: Configure and control type enforcement levels.

```elixir
defmodule Jido.TypeEnforcement do
  @moduledoc """
  Provides configuration and control over type enforcement levels
  at runtime with fine-grained control per module or globally.
  """
  
  @type level :: :none | :log | :warn | :strict
  @type config :: %{
    default_level: level(),
    module_levels: %{module() => level()},
    reporting: reporting_config()
  }
  @type reporting_config :: %{
    log_violations: boolean(),
    telemetry_events: boolean(),
    error_aggregation: boolean()
  }
  
  @doc """
  Sets the global enforcement level.
  """
  @spec set_level(level()) :: :ok
  def set_level(level)
  
  @doc """
  Sets the enforcement level for a specific module.
  """
  @spec set_module_level(module(), level()) :: :ok
  def set_module_level(module, level)
  
  @doc """
  Temporarily enforces a level for a block of code.
  
  ## Example
  
      enforce :strict do
        MyModule.dangerous_operation(params)
      end
  """
  defmacro enforce(level, do: block)
  
  @doc """
  Gets the current enforcement configuration.
  """
  @spec get_config() :: config()
  def get_config()
  
  @doc """
  Resets all enforcement to defaults.
  """
  @spec reset() :: :ok
  def reset()
end
```

## Integration Examples

### With Actions

```elixir
defmodule MyApp.Actions.CreateUser do
  use Jido.Action
  use Jido.TypeContract
  
  defcontract :input do
    required :name, :string, min_length: 1
    required :email, :string, format: ~r/@/
    optional :age, :integer, min: 18
  end
  
  defcontract :output do
    required :id, :string
    required :created_at, :datetime
    required :user, MyApp.User
  end
  
  @impl true
  @guard input: :input, output: :output
  def run(params, context) do
    # Type-safe interior
    user = MyApp.create_user!(params)
    {:ok, %{id: user.id, created_at: user.created_at, user: user}}
  end
end
```

### With Agents

```elixir
defmodule MyApp.Agents.DataProcessor do
  use Jido.Agent
  use Jido.TypeContract
  
  defcontract :state do
    required :status, :atom, in: [:idle, :processing, :complete]
    required :items_processed, :integer, min: 0
    optional :last_error, :string
  end
  
  @impl true
  @guard input: :state
  def on_before_run(agent) do
    # Validate state before running
    {:ok, agent}
  end
end
```

## Performance Considerations

1. **Compile-Time Optimization**: Contracts are compiled into efficient pattern matches
2. **Caching**: Validation results are cached for repeated validations
3. **Lazy Validation**: Only validates fields that are accessed
4. **Fast Path**: Skip validation in production with `:none` enforcement level

## Error Handling

All type violations result in detailed error structures:

```elixir
{:error, [
  %{
    field: :email,
    value: "invalid-email",
    error: "does not match format ~r/@/",
    path: [:user, :email]
  }
]}
```

## Telemetry Integration

The library emits telemetry events for monitoring:

- `[:jido, :type, :validation, :start]`
- `[:jido, :type, :validation, :stop]`
- `[:jido, :type, :violation]`
- `[:jido, :type, :cache, :hit]`
- `[:jido, :type, :cache, :miss]`

## Migration Path

1. Add `{:jido_type_enforcement, "~> 1.0"}` to deps
2. Add `use Jido.TypeContract` to modules
3. Define contracts for existing functions
4. Enable enforcement gradually with `Jido.TypeEnforcement.set_level(:log)`
5. Fix violations
6. Move to `:strict` enforcement
</file>

<file path="type_perimeters_design.md">
# Jido Type Perimeters Design: Defensive Perimeter with Offensive Interior

## Executive Summary

This document presents an innovative approach to type safety in Elixir metaprogramming, specifically designed for the Jido framework. We introduce a **"Defensive Perimeter / Offensive Interior"** pattern that allows maximum metaprogramming flexibility while maintaining strict type contracts at system perimeters.

## Core Innovation: Type Enforcement Zones

### The Three-Zone Model

1. **Defensive Perimeter (Zone 1)**: Strict type validation at API perimeters
2. **Transition Layer (Zone 2)**: Type transformation and normalization
3. **Offensive Interior (Zone 3)**: Unrestricted metaprogramming with runtime guarantees

```
┌─────────────────────────────────────────────────┐
│            DEFENSIVE PERIMETER                  │
│  ┌───────────────────────────────────────────┐  │
│  │         TRANSITION LAYER                  │  │
│  │  ┌───────────────────────────────────┐   │  │
│  │  │    OFFENSIVE INTERIOR             │   │  │
│  │  │  (Metaprogramming Freedom)        │   │  │
│  │  └───────────────────────────────────┘   │  │
│  └───────────────────────────────────────────┘  │
└─────────────────────────────────────────────────┘
```

## Type Contract Enforcement Mechanisms

### 1. Compile-Time Contract Definition

```elixir
defmodule Jido.TypeContract do
  @moduledoc """
  Defines compile-time type contracts that are enforced at runtime perimeters.
  """
  
  defmacro defcontract(name, do: block) do
    quote do
      Module.register_attribute(__MODULE__, :type_contracts, accumulate: true)
      
      @type_contracts {unquote(name), unquote(Macro.escape(block))}
      
      def __contract__(unquote(name)) do
        unquote(block)
      end
    end
  end
end
```

### 2. Runtime Perimeter Guards

```elixir
defmodule Jido.PerimeterGuard do
  @moduledoc """
  Enforces type contracts at runtime perimeters using pluggable validation strategies.
  """
  
  defmacro guard_perimeter(function_name, contract_name) do
    quote do
      defoverridable [{unquote(function_name), 2}]
      
      def unquote(function_name)(params, context) do
        case Jido.PerimeterGuard.validate_input(__MODULE__, unquote(contract_name), params, context) do
          {:ok, validated_params, validated_context} ->
            result = super(validated_params, validated_context)
            Jido.PerimeterGuard.validate_output(__MODULE__, unquote(contract_name), result)
            
          {:error, violations} ->
            {:error, Jido.Error.validation_error("Contract violation", violations)}
        end
      end
    end
  end
end
```

### 3. Type Shape Definitions

```elixir
defmodule Jido.TypeShape do
  @moduledoc """
  Defines reusable type shapes that can be composed and validated.
  """
  
  defstruct [:name, :fields, :validators, :transformers]
  
  def shape(name, fields) do
    %__MODULE__{
      name: name,
      fields: normalize_fields(fields),
      validators: [],
      transformers: []
    }
  end
  
  def validate(%__MODULE__{} = shape, data) do
    # Efficient validation using compile-time optimized paths
  end
end
```

## Practical Implementation Strategy

### Phase 1: Perimeter Identification

1. **Action Perimeters**
   - Entry: `Action.run/2`
   - Exit: Action result tuples
   - Contract: Input schema + Output schema

2. **Agent Perimeters**
   - Entry: `Agent.plan/3`, `Agent.run/1`
   - Exit: `Agent.result`
   - Contract: State schema + Instruction validation

3. **Instruction Perimeters**
   - Entry: `Instruction.normalize/3`
   - Exit: Normalized instruction structs
   - Contract: Action module validation + Params validation

### Phase 2: Contract Definition Language

```elixir
defmodule MyAction do
  use Jido.Action
  use Jido.TypeContract
  
  defcontract :input do
    required :user_id, :string, format: ~r/^user_\d+$/
    required :amount, :decimal, min: 0
    optional :metadata, :map do
      optional :source, :string
      optional :timestamp, :datetime
    end
  end
  
  defcontract :output do
    required :transaction_id, :string
    required :status, :atom, in: [:success, :pending, :failed]
    required :processed_at, :datetime
  end
  
  @impl true
  guard_perimeter :run, :input
  def run(params, context) do
    # Interior zone - full metaprogramming freedom
    # Types are already validated at perimeter
  end
end
```

### Phase 3: Progressive Type Enforcement

```elixir
defmodule Jido.TypeEnforcement do
  @enforcement_levels [:none, :log, :warn, :strict]
  
  def configure(module, level) when level in @enforcement_levels do
    # Configure per-module enforcement
  end
  
  defmacro enforce(level, do: block) do
    quote do
      old_level = Process.get(:type_enforcement_level, :warn)
      Process.put(:type_enforcement_level, unquote(level))
      try do
        unquote(block)
      after
        Process.put(:type_enforcement_level, old_level)
      end
    end
  end
end
```

## Type Relationship Tables

### Contract Inheritance Hierarchy

| Parent Type | Child Type | Inheritance Rule | Validation Strategy |
|-------------|------------|------------------|---------------------|
| `Jido.Agent.t()` | `MyAgent.t()` | Structural Extension | Parent fields + Child fields |
| `Action.result()` | `{:ok, map()}` | Tagged Union | Pattern match validation |
| `Instruction.t()` | Action module | Reference | Module behavior check |
| `Agent.state()` | User-defined map | Schema-based | NimbleOptions validation |

### Perimeter Crossing Rules

| From Zone | To Zone | Required Validation | Transformation |
|-----------|---------|-------------------|----------------|
| External API | Defensive | Full contract validation | Input normalization |
| Defensive | Transition | Type shape verification | Structure alignment |
| Transition | Offensive | Minimal guards | None |
| Offensive | Transition | Result normalization | Output shaping |
| Transition | Defensive | Output contract validation | Error wrapping |

### Type Propagation Matrix

| Operation | Input Types | Output Types | Contract Enforcement |
|-----------|-------------|--------------|---------------------|
| `Action.run/2` | `params :: map(), context :: map()` | `{:ok, map()} \| {:error, Error.t()}` | Input schema + Output schema |
| `Agent.plan/3` | `agent :: t(), instruction, params` | `{:ok, t()}` | Instruction validation |
| `Exec.run/4` | `action :: module(), params, context, opts` | Action result type | Action contract |
| `Instruction.normalize/3` | Various formats | `{:ok, [Instruction.t()]}` | Structural validation |

## Custom Credo Checks

### 1. Perimeter Violation Check

```elixir
defmodule Credo.Check.Warning.TypePerimeterViolation do
  use Credo.Check
  
  def run(source_file, params) do
    # Detect direct field access across module perimeters
    # Flag any code that bypasses perimeter guards
  end
end
```

### 2. Contract Completeness Check

```elixir
defmodule Credo.Check.Warning.IncompleteTypeContract do
  use Credo.Check
  
  def run(source_file, params) do
    # Ensure all public functions have contracts
    # Verify contract coverage
  end
end
```

## Programmatic Type Enforcement

### Runtime Contract Validation

```elixir
defmodule Jido.Runtime.TypeValidator do
  @moduledoc """
  Provides runtime type validation with performance optimization.
  """
  
  use GenServer
  
  def start_link(opts) do
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end
  
  def validate(module, function, args) do
    GenServer.call(__MODULE__, {:validate, module, function, args})
  end
  
  @impl true
  def init(opts) do
    # Build optimized validation paths at startup
    {:ok, build_validation_cache(opts)}
  end
end
```

### Development Mode Type Checking

```elixir
defmodule Jido.Dev.TypeChecker do
  @moduledoc """
  Enhanced type checking for development mode with detailed reporting.
  """
  
  defmacro __using__(_opts) do
    if Mix.env() == :dev do
      quote do
        @before_compile Jido.Dev.TypeChecker
      end
    end
  end
  
  defmacro __before_compile__(_env) do
    quote do
      def __type_check__ do
        # Perform comprehensive type analysis
        # Generate detailed type reports
      end
    end
  end
end
```

## Integration with Existing Patterns

### 1. With NimbleOptions

```elixir
defmodule Jido.TypeContract.NimbleAdapter do
  def to_nimble_schema(contract) do
    # Convert TypeContract to NimbleOptions schema
  end
  
  def from_nimble_schema(schema) do
    # Convert NimbleOptions schema to TypeContract
  end
end
```

### 2. With Dialyzer

```elixir
defmodule Jido.TypeContract.DialyzerHints do
  @moduledoc """
  Generates Dialyzer-compatible type specifications from contracts.
  """
  
  defmacro generate_specs(contract_name) do
    quote do
      @spec unquote(contract_name)(map()) :: {:ok, map()} | {:error, [violation()]}
    end
  end
end
```

## Benefits of This Approach

1. **Practical**: Works with existing Elixir tooling
2. **Flexible**: Allows full metaprogramming within perimeters
3. **Safe**: Enforces contracts at critical points
4. **Performant**: Validation only at perimeters, not throughout
5. **Gradual**: Can be adopted incrementally
6. **Debuggable**: Clear violation reports with context

## Next Steps

1. Implement core `Jido.TypeContract` module
2. Create perimeter guard macros
3. Develop Credo checks for perimeter violations
4. Build development-mode type checker
5. Create migration guide for existing code
</file>

<file path="type_relationships_formal_spec.md">
# Formal Type Relationships in Jido Framework

## Type Hierarchy and Relationships

### Core Type Definitions

| Type | Module | Definition | Purpose |
|------|--------|------------|---------|
| `action()` | `Jido.Action` | `module()` | Action behavior implementation |
| `agent()` | `Jido.Agent` | `%Jido.Agent{}` struct | Stateful workflow executor |
| `instruction()` | `Jido.Instruction` | `%Jido.Instruction{}` struct | Normalized work unit |
| `error()` | `Jido.Error` | `%Jido.Error{}` struct | Standardized error representation |
| `directive()` | `Jido.Agent.Directive` | `%{type, target, value}` | State modification instruction |

### Type Transformation Pipeline

| Stage | Input Type | Operation | Output Type | Contract |
|-------|------------|-----------|-------------|----------|
| 1 | `module \| {module, map}` | `Instruction.normalize/3` | `{:ok, [Instruction.t]}` | Module validation |
| 2 | `Instruction.t` | `Action.validate_params/1` | `{:ok, map} \| {:error, Error.t}` | Schema validation |
| 3 | `{params, context}` | `Action.run/2` | `action_result()` | Runtime execution |
| 4 | `action_result()` | `Action.validate_output/1` | `{:ok, map} \| {:error, Error.t}` | Output validation |
| 5 | `{:ok, map, directives}` | `Directive.apply/2` | `{:ok, agent()} \| {:error, Error.t}` | State application |

### Structural Type Relationships

#### Action Type Family

| Type | Structure | Constraints | Usage Context |
|------|-----------|-------------|---------------|
| `action_result()` | `{:ok, map()}` | Map keys match output_schema | Simple success |
| | `{:ok, map(), directive()}` | Map validated, directive well-formed | Success with side effects |
| | `{:ok, map(), [directive()]}` | Map validated, all directives valid | Success with multiple effects |
| | `{:error, Error.t()}` | Error has valid type | Simple failure |
| | `{:error, Error.t(), directive()}` | Error typed, directive for cleanup | Failure with compensation |

#### Agent Type Family

| Type | Structure | Constraints | Usage Context |
|------|-----------|-------------|---------------|
| `agent_result()` | `{:ok, Agent.t()}` | State validated against schema | Successful operation |
| | `{:error, Error.t()}` | Error indicates failure reason | Operation failure |
| `agent_state()` | `map()` | Validates against agent schema | Internal state storage |
| `pending_instructions()` | `:queue.queue()` | Contains valid instructions | Execution queue |

#### Instruction Type Family

| Type | Structure | Constraints | Usage Context |
|------|-----------|-------------|---------------|
| `instruction()` | `module()` | Must implement Action behavior | Simple action reference |
| | `{module(), map()}` | Module valid, params are map | Action with parameters |
| | `%Instruction{}` | All fields properly typed | Normalized instruction |
| `instruction_list()` | `[instruction()]` | No nested lists allowed | Batch operations |

### Type Validation Perimeters

| Perimeter | Validated Types | Validation Method | Enforcement Level |
|----------|----------------|-------------------|-------------------|
| Action Entry | `params :: map()` | Schema validation | Strict |
| Action Exit | `result :: map()` | Output schema validation | Configurable |
| Agent State Change | `state :: map()` | State schema validation | Strict |
| Instruction Creation | `action :: module()` | Behavior implementation | Strict |
| Error Propagation | `error :: Error.t()` | Type field validation | Required |

### Cross-Module Type Dependencies

```
┌─────────────────────────────────────────────────────────────┐
│                     Type Dependency Graph                    │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Jido.Action ─────uses────> Jido.Error                     │
│      │                           ^                          │
│      │                           │                          │
│      └────produces───> action_result                       │
│                              │                              │
│                              │                              │
│  Jido.Instruction ───────────┘                             │
│      │                                                      │
│      └────references───> action :: module()                │
│                                                             │
│  Jido.Agent ─────contains───> Instruction.t()              │
│      │                                                      │
│      └────maintains───> state :: map()                     │
│                                                             │
│  Jido.Agent.Directive ───modifies───> Agent.state          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Type Coercion Rules

| From Type | To Type | Coercion Function | Safety |
|-----------|---------|-------------------|---------|
| `keyword()` | `map()` | `Map.new/1` | Safe |
| `any()` | `map()` | `validate_map_shape/1` | Validated |
| `String.t()` | `atom()` | `String.to_existing_atom/1` | Safe with guard |
| `{:ok, value}` | `value` | `unwrap_ok/1` | Checked |
| `module()` | `Instruction.t()` | `Instruction.new!/1` | Validated |

### Polymorphic Type Patterns

| Pattern | Type Expression | Runtime Behavior | Example |
|---------|-----------------|------------------|---------|
| Union Types | `{:ok, T} \| {:error, E}` | Pattern matching | Result tuples |
| Tagged Unions | `{tag :: atom(), value :: any()}` | Tag-based dispatch | Directives |
| Protocol Dispatch | `impl_for(module)` | Module-based polymorphism | Action behaviors |
| Parametric | `[T]` where T is consistent | List operations | Instruction lists |

### Type Contract Composition

| Composition Type | Definition | Example | Validation |
|-----------------|------------|---------|------------|
| Sequential | `A -> B -> C` | `params -> validated -> result` | Each step validated |
| Parallel | `{A, B, C}` | Multiple directives | All must succeed |
| Alternative | `A \| B \| C` | Result types | First match wins |
| Nested | `A<B<C>>` | `Agent<State<Map>>` | Recursive validation |

### Error Type Propagation

| Error Origin | Type | Propagation Path | Final Type |
|--------------|------|------------------|------------|
| Validation | `:validation_error` | Action -> Exec -> Agent | `{:error, Error.t()}` |
| Execution | `:execution_error` | Action runtime -> Exec | `{:error, Error.t()}` |
| Timeout | `:timeout` | Exec perimeter -> Agent | `{:error,            Error.t()}` |
| Planning | `:planning_error` | Agent planner -> Result | `{:error, Error.t()}` |

### Type Safety Guarantees

| Guarantee | Mechanism | Verification | Coverage |
|-----------|-----------|--------------|----------|
| Input Safety | Schema validation | Compile + Runtime | 100% of actions |
| Output Safety | Output validation | Runtime | Configurable |
| State Safety | State schema | Runtime | All state changes |
| Error Safety | Error type system | Compile-time | All error paths |
| Directive Safety | Type checking | Runtime | All directives |

### Type System Evolution Rules

| Change Type | Allowed | Migration Strategy | Risk Level |
|-------------|---------|-------------------|------------|
| Add optional field | ✓ | Backward compatible | Low |
| Add required field | ✗ | Major version bump | High |
| Change field type | ✗ | Adapter pattern | High |
| Add new error type | ✓ | Extend error union | Low |
| Remove field | ✗ | Deprecation cycle | High |
| Add type constraint | ~ | Gradual enforcement | Medium |

### Performance Characteristics

| Type Operation | Complexity | Optimization | Cache Strategy |
|----------------|------------|--------------|----------------|
| Schema validation | O(n) fields | Compile-time paths | Result caching |
| Type coercion | O(1) | Direct dispatch | Not needed |
| Error creation | O(1) | Struct allocation | Not cached |
| Directive application | O(1) | Pattern match | Not needed |
| Contract checking | O(n) rules | Rule compilation | Compiled contracts |

## Type Contract Verification Examples

### Action Contract Verification

```elixir
# Type: Action.run/2 :: (map(), map()) -> action_result()
# Contract: params match schema AND result matches output_schema

verify_action_contract(MyAction) ->
  # Input contract
  assert validate_params(sample_params) == {:ok, validated}
  
  # Execution contract  
  assert {:ok, result} = run(validated, context)
  
  # Output contract
  assert validate_output(result) == {:ok, result}
```

### Agent State Contract

```elixir
# Type: Agent.state :: map()
# Contract: state always validates against agent schema

verify_agent_state(agent) ->
  # State modification contract
  assert {:ok, new_agent} = set(agent, changes)
  assert validate_state(new_agent.state) == {:ok, _}
  
  # State invariants maintained
  assert map_size(new_agent.state) >= map_size(agent.state)
```

### Instruction Normalization Contract

```elixir
# Type: normalize/3 :: (various, map(), keyword()) -> {:ok, [Instruction.t()]}
# Contract: Always returns list of valid instructions

verify_instruction_normalization() ->
  # Module normalization
  assert {:ok, [%Instruction{action: Mod}]} = normalize(Mod)
  
  # Tuple normalization  
  assert {:ok, [%Instruction{params: params}]} = normalize({Mod, params})
  
  # List normalization
  assert {:ok, instructions} = normalize([Mod1, {Mod2, params}])
  assert length(instructions) == 2
```
</file>

<file path="type_safe_metaprogramming_patterns.md">
# Type-Safe Metaprogramming Patterns for Elixir

## Overview

This guide synthesizes the innovative "Defensive Perimeter / Offensive Interior" pattern with Elixir's idioms to create type-safe metaprogramming practices that avoid common antipatterns while preserving the language's dynamic power.

## Core Principle: Assertive Perimeters, Dynamic Interiors

The fundamental insight is that type safety in Elixir doesn't require abandoning metaprogramming. Instead, we establish **assertive type perimeters** around **dynamic interiors**, creating zones where different rules apply:

1. **Perimeter Zone**: Strict validation, pattern matching, and type contracts
2. **Interior Zone**: Full metaprogramming freedom with runtime guarantees

This approach directly addresses the antipatterns of non-assertive programming while enabling powerful dynamic features.

## Pattern 1: Contract-Based Module Generation

### Antipattern Avoided: Non-Assertive Pattern Matching

Instead of defensive programming that accepts any input, we use contracts to enforce structure at compile-time:

```elixir
defmodule Jido.DefineAction do
  use Jido.TypeContract
  
  defcontract :action_definition do
    required :name, :atom
    required :schema, :keyword_list
    optional :output_schema, :keyword_list
    optional :description, :string
  end
  
  defmacro define_action(definition) do
    # Validate at compile time
    case validate_contract(:action_definition, definition) do
      {:ok, validated} ->
        generate_action_module(validated)
      {:error, violations} ->
        raise CompileError, description: format_violations(violations)
    end
  end
  
  defp generate_action_module(definition) do
    quote do
      defmodule unquote(definition.name) do
        use Jido.Action
        
        # Metaprogramming interior - validated data allows freedom
        unquote(generate_schema(definition.schema))
        unquote(generate_callbacks(definition))
      end
    end
  end
end
```

### Usage

```elixir
# Compile-time validation ensures correctness
DefineAction.define_action(
  name: MyApp.Actions.CreateUser,
  schema: [
    name: [type: :string, required: true],
    email: [type: :string, format: ~r/@/]
  ],
  output_schema: [
    id: [type: :string],
    created_at: [type: :datetime]
  ]
)
```

## Pattern 2: Assertive Dynamic Dispatch

### Antipattern Avoided: Dynamic Atom Creation

Instead of converting arbitrary strings to atoms, we use a registry pattern with explicit contracts:

```elixir
defmodule Jido.ActionRegistry do
  use GenServer
  use Jido.TypeContract
  
  defcontract :registration do
    required :name, :string, format: ~r/^[a-z_]+$/
    required :module, :atom
    required :category, :atom, in: [:data, :workflow, :integration]
  end
  
  def register_action(attrs) do
    with {:ok, validated} <- validate_contract(:registration, attrs),
         :ok <- validate_module_exists(validated.module),
         :ok <- validate_implements_behavior(validated.module, Jido.Action) do
      GenServer.call(__MODULE__, {:register, validated})
    end
  end
  
  def dispatch(name, params, context) when is_binary(name) do
    case lookup_action(name) do
      {:ok, module} ->
        # Perimeter crossed - now in validated interior
        Jido.Exec.run(module, params, context)
      :error ->
        {:error, Jido.Error.not_found("Action not registered", %{name: name})}
    end
  end
  
  defp lookup_action(name) do
    # No dynamic atom creation - only pre-registered atoms
    GenServer.call(__MODULE__, {:lookup, name})
  end
end
```

## Pattern 3: Type-Safe Dynamic Configuration

### Antipattern Avoided: Non-Assertive Map Access

Instead of defensive map access, we use structured configuration with compile-time validation:

```elixir
defmodule Jido.Config do
  use Jido.TypeContract
  
  defcontract :action_config do
    required :timeout, :integer, min: 0, max: 300_000
    required :retries, :integer, min: 0, max: 10
    optional :telemetry, :atom, in: [:full, :minimal, :none]
    
    optional :hooks, :map do
      optional :before_run, {:list, :atom}
      optional :after_run, {:list, :atom}
    end
  end
  
  defmacro configure(module, config) do
    case validate_contract(:action_config, config) do
      {:ok, validated} ->
        quote do
          @action_config unquote(Macro.escape(validated))
          
          # Assertive access - we know these fields exist
          def timeout, do: @action_config.timeout
          def retries, do: @action_config.retries
          
          # Optional access for optional fields
          def telemetry, do: @action_config[:telemetry] || :minimal
          def hooks, do: @action_config[:hooks] || %{}
        end
      {:error, violations} ->
        raise CompileError, description: format_violations(violations)
    end
  end
end

# Usage
defmodule MyAction do
  use Jido.Action
  use Jido.Config
  
  configure MyAction,
    timeout: 5_000,
    retries: 3,
    hooks: %{
      before_run: [:validate_permissions, :log_attempt]
    }
end
```

## Pattern 4: Perimeter-Enforced Metaprogramming

### Antipattern Avoided: Complex else Clauses in with

Instead of complex error handling, we normalize at perimeters:

```elixir
defmodule Jido.Workflow do
  use Jido.TypeContract
  
  defcontract :step do
    required :action, :atom
    required :input_transform, :function
    required :error_handler, :atom, in: [:retry, :skip, :halt]
  end
  
  defmacro defworkflow(name, steps) do
    validated_steps = Enum.map(steps, fn step ->
      case validate_contract(:step, step) do
        {:ok, valid} -> valid
        {:error, violations} ->
          raise CompileError, description: 
            "Invalid workflow step: #{format_violations(violations)}"
      end
    end)
    
    quote do
      def unquote(name)(initial_params, context) do
        # Interior: validated steps allow clean with expression
        unquote(generate_workflow_with(validated_steps))
      end
    end
  end
  
  defp generate_workflow_with(steps) do
    # Generate clean with expression without complex else
    step_clauses = Enum.map(steps, fn step ->
      quote do
        {unquote(step.action), result} <- 
          execute_step(unquote(step), previous_result)
      end
    end)
    
    quote do
      with unquote_splicing(step_clauses) do
        {:ok, result}
      end
    end
  end
  
  defp execute_step(step, input) do
    # Perimeter enforcement before action execution
    transformed = step.input_transform.(input)
    
    case Jido.Exec.run(step.action, transformed, %{}) do
      {:ok, result} -> {step.action, {:ok, result}}
      {:error, error} -> handle_step_error(step, error)
    end
  end
end
```

## Pattern 5: Type-Safe Code Generation

### Combining Multiple Patterns

This example shows how to combine assertive perimeters with dynamic code generation:

```elixir
defmodule Jido.GenerateStateMachine do
  use Jido.TypeContract
  
  defcontract :state_definition do
    required :name, :atom
    required :events, {:list, :event}
  end
  
  defcontract :event do
    required :name, :atom
    required :from, {:list, :atom}
    required :to, :atom
    optional :guard, :function
  end
  
  defmacro generate(definition) do
    with {:ok, validated} <- validate_contract(:state_definition, definition),
         :ok <- validate_state_graph(validated) do
      generate_state_machine(validated)
    else
      {:error, reason} ->
        raise CompileError, description: format_error(reason)
    end
  end
  
  defp generate_state_machine(%{name: name, events: events}) do
    # Assertive pattern matching on validated structure
    event_functions = Enum.map(events, &generate_event_function/1)
    
    quote do
      defmodule unquote(name) do
        use GenServer
        
        # Type contracts for runtime perimeters
        use Jido.TypeContract
        
        defcontract :state do
          required :current, :atom
          required :data, :map
          required :history, {:list, :atom}
        end
        
        # Generated functions with perimeter guards
        unquote_splicing(event_functions)
        
        # Assertive state access
        def current_state(%{current: current}), do: current
        def state_data(%{data: data}), do: data
      end
    end
  end
  
  defp generate_event_function(%{name: event, from: from_states, to: to_state} = event_def) do
    quote do
      def unquote(event)(state) do
        # Pattern match ensures we're in a valid from state
        %{current: current} = state
        
        if current in unquote(from_states) do
          # Apply guard if present
          if unquote(apply_guard(event_def)) do
            {:ok, %{state | current: unquote(to_state), 
                           history: [current | state.history]}}
          else
            {:error, :guard_failed}
          end
        else
          {:error, {:invalid_transition, current, unquote(event)}}
        end
      end
    end
  end
end
```

## Best Practices Summary

### 1. Validate at Compile Time When Possible

```elixir
# Good: Compile-time validation
defmacro define_handler(name, opts) do
  validated_opts = validate_at_compile_time!(opts)
  # ... generate code with validated opts
end

# Avoid: Runtime validation in macros
defmacro define_handler(name, opts) do
  quote do
    opts = validate_opts(unquote(opts))  # Too late!
  end
end
```

### 2. Use Pattern Matching for Structure Assertion

```elixir
# Good: Assertive pattern matching
def process(%User{id: id, name: name} = user) when is_binary(name) do
  # We know the structure is correct
end

# Avoid: Defensive checking
def process(user) do
  if is_map(user) && Map.has_key?(user, :id) do
    # Defensive and unclear
  end
end
```

### 3. Separate Perimeter Validation from Interior Logic

```elixir
defmodule MyAction do
  # Perimeter: strict validation
  @guard input: :user_input
  def run(params, context) do
    # Interior: work with validated data
    transform_and_process(params)
  end
  
  # Pure interior logic without validation concerns
  defp transform_and_process(validated_params) do
    # Free to use metaprogramming, dynamic dispatch, etc.
  end
end
```

### 4. Make Contracts Explicit and Reusable

```elixir
defmodule SharedContracts do
  use Jido.TypeContract
  
  defcontract :pagination do
    optional :page, :integer, min: 1, default: 1
    optional :limit, :integer, min: 1, max: 100, default: 20
  end
  
  defcontract :user_identity do
    required :user_id, :string, format: ~r/^user_\d+$/
    optional :session_id, :string
  end
end
```

### 5. Provide Clear Error Messages at Perimeters

```elixir
def create_action(params) do
  case validate_contract(:action_params, params) do
    {:ok, validated} ->
      do_create(validated)
    {:error, violations} ->
      {:error, %Jido.Error{
        type: :validation_error,
        message: "Invalid action parameters",
        details: %{
          violations: format_violations(violations),
          hint: "Check the required fields and their types"
        }
      }}
  end
end
```

## Conclusion

By combining the "Defensive Perimeter / Offensive Interior" pattern with Elixir's existing idioms, we can w ```change all variations of perimeter in the doc to the same     │
│    variation of perimeter, and rename any doc name with a varation of perimeter wiht the apporpriate         │
│    variation of perinmeterrite code that is both type-safe and dynamically powerful. The key is to:

1. **Be assertive at perimeters** - Use pattern matching, guards, and contracts
2. **Validate early** - Catch errors at compile-time when possible
3. **Trust the interior** - Once validated, use Elixir's full power
4. **Make contracts explicit** - Clear, reusable type definitions
5. **Fail fast and clearly** - Provide actionable error messages

This approach gives us the best of both worlds: the safety of typed systems at perimeters and the flexibility of dynamic metaprogramming in our implementation.````
</file>

</files>
